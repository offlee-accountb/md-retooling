#!/usr/bin/env python3
"""Phase1: Minimal MD → HWPX converter skeleton.

Goal (MVP):
- Read `sample_input.md`-style markdown.
- Parse lines into typed blocks (TITLE, SUBTITLE, BODY, DESC2, DESC3, EMPHASIS, PLAIN).
- Build an in-memory HWPX-like XML tree (single section, simple run/para structure).
- Save to `.hwpx` file (ZIP container with minimal XMLs).

NOTE:
- This is a skeleton: XML structure is intentionally simple and will be
  refined against the HWPX spec using `tools/spec_search.py`.
- For now we only guarantee that the output is a well-formed ZIP+XML file.
"""
from __future__ import annotations

import sys
from dataclasses import dataclass
from datetime import datetime, timezone
from enum import Enum, auto
from pathlib import Path
from typing import Iterable, List, Optional, TYPE_CHECKING
import argparse
import base64
import getpass
import re
import zipfile
import xml.etree.ElementTree as ET

# Style config loading
sys.path.insert(0, str(Path(__file__).parent.parent))
from validator.template_loader import load_style_config, StyleConfig

# ---------------------------------------------------------------------------
# Load style configuration (YAML-based)
# ---------------------------------------------------------------------------

_DEFAULT_STYLE_PATH = Path(__file__).parent.parent / "templates" / "core_styles.yaml"

def _load_config() -> StyleConfig:
    """Load style configuration from YAML."""
    if _DEFAULT_STYLE_PATH.exists():
        return load_style_config(_DEFAULT_STYLE_PATH)
    # Fallback: return empty config (will use hardcoded defaults)
    from validator.template_loader import StyleConfig
    return StyleConfig(version="1.0", template_id="fallback", description="Hardcoded fallback")

CONFIG: StyleConfig = _load_config()

# ---------------------------------------------------------------------------
# Data model for parsed markdown
# ---------------------------------------------------------------------------


class BlockType(Enum):
    TITLE = auto()       # <주제목>
    SUBTITLE = auto()    # □
    BODY = auto()        # ◦
    DESC2 = auto()       # - (3 spaces)
    DESC3 = auto()       # * (4 spaces)
    EMPHASIS = auto()    # <강조>
    TABLE = auto()       # markdown table
    SUMMARY_TABLE = auto()  # <요약표> 전용
    PLAIN = auto()       # fallback / other


@dataclass
class Block:
    type: BlockType
    raw: str            # original line
    text: str           # content without leading markers


@dataclass
class TableBlock(Block):
    """Markdown 표를 담는 특수 블록."""

    title: str
    header: List[str]
    aligns: List[str]
    rows: List[List[str]]


@dataclass
class SummaryTableBlock(Block):
    """요약표(<요약표 시작> ~ <요약표 끝>) 범위를 하나의 표로 묶는다."""

    items: List[Block]


@dataclass
class DocumentMetadata:
    title: str
    creator: str
    subject: str
    description: str
    last_saved_by: str
    keyword: str
    created_at: datetime
    modified_at: datetime
    display_date: str


# ---------------------------------------------------------------------------
# Style mapping layer (logical BlockType → paraPr/charPr IDs)
# Dynamically built from CONFIG (core_styles.yaml)
# ---------------------------------------------------------------------------

def _build_style_maps() -> tuple:
    """CONFIG에서 PARA_STYLE_MAP, RUN_CHAR_OVERRIDE_MAP, STYLE_ID_MAP 생성."""
    # BlockType 이름 → YAML 키 매핑
    block_to_yaml = {
        BlockType.TITLE: "title",
        BlockType.SUBTITLE: "subtitle",
        BlockType.BODY: "body",
        BlockType.DESC2: "desc2",
        BlockType.DESC3: "desc3",
        BlockType.EMPHASIS: "emphasis",
        BlockType.PLAIN: "plain",
    }
    
    para_map = {}
    char_map = {}
    style_map = {}
    
    for block_type, yaml_key in block_to_yaml.items():
        style = CONFIG.get_style(yaml_key)
        if style:
            para_map[block_type] = str(style.para_pr_id)
            char_map[block_type] = str(style.char_pr_id)
            style_map[block_type] = str(style.style_id)
        else:
            # Fallback to 0 if not defined
            para_map[block_type] = "0"
            char_map[block_type] = "0"
            style_map[block_type] = "0"
    
    return para_map, char_map, style_map

PARA_STYLE_MAP, RUN_CHAR_OVERRIDE_MAP, STYLE_ID_MAP = _build_style_maps()

INLINE_BOLD_CHAR_ID = RUN_CHAR_OVERRIDE_MAP[BlockType.EMPHASIS]

# ---------------------------------------------------------------------------
# Config-driven constants (from core_styles.yaml via CONFIG)
# ---------------------------------------------------------------------------

HWPUNITS_PER_MM = CONFIG.hwp_per_mm

# Page dimensions
PAGE_WIDTH_MM = CONFIG.page.width_mm
PAGE_HEIGHT_MM = CONFIG.page.height_mm
PAGE_WIDTH_HWP = str(CONFIG.page.width_hwp)
PAGE_HEIGHT_HWP = str(CONFIG.page.height_hwp)

# Page margins
MARGIN_TOP_MM = CONFIG.page.margins_mm.get("top", 15.0)
MARGIN_BOTTOM_MM = CONFIG.page.margins_mm.get("bottom", 15.0)
MARGIN_LEFT_MM = CONFIG.page.margins_mm.get("left", 20.0)
MARGIN_RIGHT_MM = CONFIG.page.margins_mm.get("right", 20.0)
MARGIN_HEADER_MM = CONFIG.page.margins_mm.get("header", 10.0)
MARGIN_FOOTER_MM = CONFIG.page.margins_mm.get("footer", 10.0)
PAGE_BORDER_OFFSET_MM = CONFIG.page.border_offset_mm

# Table dimensions (from CONFIG.tables)
TABLE_WIDTH_HWP = str(CONFIG.tables.width_hwp) if CONFIG.tables else "48189"
TITLE_BODY_HEIGHT_HWP = "3174"  # TODO: move to config
ONE_PT_HWP = str(int(round((25.4 / 72) * HWPUNITS_PER_MM)))
TITLE_TABLE_ROW_HEIGHTS = (ONE_PT_HWP, TITLE_BODY_HEIGHT_HWP, ONE_PT_HWP)
EMPH_TABLE_HEIGHT_HWP = "2632"
EMPH_TABLE_ROW_HEIGHT = "521"
TITLE_TABLE_SPACER_CHAR_ID = "9"  # 1pt filler

# Header/Footer 전용 스타일 ID (CONFIG.styles에서 동적 조회)
def _get_header_footer_ids():
    """머리말/꼬리말 스타일 ID를 CONFIG에서 가져온다."""
    hdr = CONFIG.get_style("header")
    ftr = CONFIG.get_style("footer")
    return {
        "header_para": str(hdr.para_pr_id) if hdr else "12",
        "header_char": str(hdr.char_pr_id) if hdr else "10",
        "header_style": str(hdr.style_id) if hdr else "12",
        "footer_para": str(ftr.para_pr_id) if ftr else "13",
        "footer_char": str(ftr.char_pr_id) if ftr else "10",
        "footer_style": str(ftr.style_id) if ftr else "13",
    }

_HF_IDS = _get_header_footer_ids()
HEADER_PARA_ID = _HF_IDS["header_para"]
FOOTER_PARA_ID = _HF_IDS["footer_para"]
HEADER_CHAR_ID = _HF_IDS["header_char"]
FOOTER_CHAR_ID = _HF_IDS["footer_char"]
HEADER_STYLE_ID = _HF_IDS["header_style"]
FOOTER_STYLE_ID = _HF_IDS["footer_style"]

# Table-specific style IDs (TODO: migrate to CONFIG.tables.styles)
TABLE_TITLE_PARA_ID = "14"
TABLE_HEADER_PARA_ID = "15"
TABLE_BODY_PARA_ID = "16"
SUMMARY_TABLE_PARA_ID = "17"   # 단일 셀 wrapper
SUMMARY_BODY_PARA_ID = "18"
SUMMARY_DESC_PARA_ID = "19"
TABLE_TITLE_STYLE_ID = "14"
TABLE_HEADER_STYLE_ID = "15"
TABLE_BODY_STYLE_ID = "16"
SUMMARY_BODY_STYLE_ID = "17"
SUMMARY_DESC_STYLE_ID = "18"
TABLE_BODY_CHAR_ID = "11"
TABLE_HEADER_CHAR_ID = "12"

# Dedicated borderFill IDs for non-standard tables
# 실험 2: 순차적 ID 사용 (ID 개수 제한 가설 검증)
TITLE_TABLE_SPACER_BORDER_ID = "34"   # 연보라 배경 + 테두리 NONE
TITLE_TABLE_BODY_BORDER_ID = "35"     # 테두리 NONE, 배경 없음
EMPH_TABLE_BORDER_ID = "36"           # 연두 배경 + SOLID 테두리
SUMMARY_TABLE_BORDER_ID = "37"        # 점선 테두리

# Spacer paragraph mapping: CONFIG.spacers에서 동적 생성
def _build_spacer_char_map():
    """CONFIG.spacers에서 SPACER_CHAR_MAP 생성."""
    block_to_yaml = {
        BlockType.SUBTITLE: "subtitle",
        BlockType.BODY: "body",
        BlockType.DESC2: "desc2",
        BlockType.DESC3: "desc3",
    }
    result = {}
    for block_type, yaml_key in block_to_yaml.items():
        spacer = CONFIG.spacers.get(yaml_key)
        if spacer:
            result[block_type] = str(spacer.char_pr_id)
    return result

SPACER_CHAR_MAP = _build_spacer_char_map()

# Spacer marker text: ↕(size)↕ so later manual/auto replace is easy
SPACER_MARKER_MAP = {
    BlockType.SUBTITLE: " ",
    BlockType.BODY: " ",
    BlockType.DESC2: " ",
    BlockType.DESC3: " ",
}


PREVIEW_PNG_BASE64 = (
    "iVBORw0KGgoAAAANSUhEUgAAAtQAAAQACAIAAABOMFmkAAAOFklEQVR42u3WoQ0AAAgEsd9/XIJA"
    "MgMG1aQTnLpUDwDAm0gAAJgPAMB8AACYDwDAfAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA5gMAMB8A"
    "AOYDADAfAADmAwAwHwAA5gMAMB8AAOYDADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwCA"
    "+QAAzAcAgPkAAMwHAGA+AADMBwBgPgAAzAcAYD4AAMwHAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+"
    "AADzAQCYDwAA8wEAmA8AAPMBAJgPAMB8AACYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMA"
    "wHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAID5AAAwHwCA+QAAMB8AgPkAADAfAID5AADM"
    "BwCA+QAAzAcAgPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMB"
    "AGA+AADzAQBgPgAA8wEAmA8AAPMBAJgPAADzAQCYDwAA8wEAmA8AwHwAAJgPAMB8AACYDwDAfAAA"
    "mA8AwHwAAOYDAMB8AADmAwDAfAAA5gMAMB8AAOYDADAfAADmAwAwHwAA5gMAMB8AgPkAADAfAID5"
    "AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwCA+QAAzAcAYD4AAMwHAGA+AADMBwBgPgAAzAcAYD4A"
    "APOhAgBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAADzAQCYDwDAfAAAmA8A"
    "wHwAAJgPAMB8AACYDwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAw"
    "HwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAzAcAgPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwH"
    "AGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAmA8AAPMBAJgPAADzAQCYDwAA8wEA"
    "mA8AwHwAAJgPAMB8AACYDwDAfAAA5gMAwHwAAOYDAMB8AADmAwDAfAAA5gMAMB8AAOYDADAfAADm"
    "AwAwHwAA5gMAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwCA+QAAzAcAYD4A"
    "AMwHAGA+AADMBwBgPgAAzAcAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA"
    "8wEAmA8AAPMBAJgPAADzAQCYDwDAfAAA"
    "mA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADm"
    "AwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAzAcAgPkAAMwHAID5AADMBwCA+QAAzAcAYD4A"
    "AMwHAGA+AADMBwBgPgAAzAcAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA"
    "8wEAmA8AAPMBAJgPAADzAQCYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8"
    "AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAzAcA"
    "gPkAAMwHAID5AADMBwCA+QAAzAcAYD4AAMwHAGA+AADMBwBgPgAAzAcAYD4AAPMBAGA+AADzAQBg"
    "PgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAADzAQCYDwDAfAAA"
    "mA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADm"
    "AwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAzAcAgPkAAMwHAID5AADMBwCA+QAAzAcAYD4A"
    "AMwHAGA+AADMBwBgPgAAzAcAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA"
    "8wEAmA8AAPMBAJgPAADzAQCYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8"
    "AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8A"
    "gPkAAMwHAID5AADMBwCA+QAAzAcAYD4AAMwHAGA+AADMBwBgPgAAzAcAYD4AAPMBAGA+AADzAQBg"
    "PgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAADzAQCYDwDAfAAA"
    "mA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADm"
    "AwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAzAcAgPkAAMwHAID5AADMBwCA+QAAzAcAYD4A"
    "AMwHAGA+AADMBwBgPgAAzAcAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA"
    "8wEAmA8AAPMBAJgPAADzAQCYDwDAfAAA"
    "mA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADm"
    "AwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwCA+QAAzAcAYD4A"
    "AMwHAGA+AADMBwBgPgAAzAcAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA"
    "8wEAmA8AAPMBAJgPAADzAQCYDwDAfAAA"
    "mA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADm"
    "AwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAzAcAgPkAAMwHAID5AADMBwCA+QAAzAcAYD4A"
    "AMwHAGA+AADMBwBgPgAAzAcAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA"
    "8wEAmA8AAPMBAJgPAADzAQCYDwDAfEgAAJgPAMB8AACYDwDAfAAAmA8AwHwAAOYDAMB8AADmAwDA"
    "fAAA5gMAwHwAAOYDADAfAADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAf"
    "AID5AAAwHwCA+QAAzAcAgPkAAMwHAID5AADMBwCA+QAAzAcAYD4AAMwHAGA+AADMBwBgPgAAzAcA"
    "YD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAADzAQCY"
    "DwDAfAAA"
    "mA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADm"
    "AwAwHwCA+VABADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwCA+QAAzAcAgPkAAMwHAGA+"
    "AADMBwBgPgAAzAcAYD4AAMwHAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8A"
    "APMBAJgPAADzAQCYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAw"
    "HwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAzAcAgPkAAMwH"
    "AID5AADMBwCA+QAAzAcAYD4AAMwHAGA+AADMBwBgPgAAzAcAYD4AAPOhAgBgPgAA8wEAYD4AAPMB"
    "AGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAADzAQCYDwDAfAAAmA8AwHwAAJgPAMB8AACYDwDAfAAA"
    "5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5"
    "AAAwHwCA+QAAzAcAgPkAAMwHAID5AADMBwCA+QAAzAcAYD4AAMwHAGA+AADMBwBgPgAAzAcAYD4A"
    "APMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAMB8AACYDwDA"
    "fAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA5gMAwHwAAOYDADAfAADmAwAwHwAA5gMAMB8AgPkAADAf"
    "AID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwHAGA+AADMBwBgPgAA8wEA"
    "YD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAJgPAADzAQCYDwAA8wEAmA8AwHxIAACYDwDAfAAA"
    "mA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADm"
    "AwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAzAcAgPkAAMwHAID5AADMBwCA+QAAzAcAYD4A"
    "AMwHAGA+AADMBwBgPgAAzAcAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA"
    "8wEAmA8AAPMBAJgPAMB8AACYDwDAfAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA5gMAwHwAAOYDADAf"
    "AADmAwAwHwAA5gMAMB8AgPlQAQAwHwCA+QAAMB8AgPkAADAfAID5AADMBwCA+QAAzAcAgPkAAMwH"
    "AID5AADMBwBgPgAAzAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEA"
    "mA8AAPMBAJgPAADzAQCYDwDAfAAAmA8AwHwAAJgPAMB8AACYDwDAfAAA5gMAwHwAAOYDAMB8AADm"
    "AwDAfAAA5gMAMB8AAOYDADAfAADmAwAwHwAA5gMAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkA"
    "AMwHAID5AADMBwCA+QAAzAcAgPkAAMwHAGA+AADMBwBgPgAAzAcAYD4AAPMBAGA+AADzAQBgPgAA"
    "8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAADzAQCYDwDAfAAAmA8AwHwAAJgPAMB8"
    "AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8A"
    "gPkAADAfAID5AAAwHwCA+QAAzAcAgPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwHAGA+AADMBwBg"
    "PgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAmA8AAPMBAJgPAADzAQCYDwDAfEgAAJgPAMB8AACY"
    "DwDAfAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA5gMAwHwAAOYDADAfAADmAwAwHwAA5gMAMB8AAOYD"
    "ADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwCA+QAAzAcAgPkAAMwHAGA+AADMBwBgPgAA"
    "zAcAYD4AAMwHAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAMB8"
    "AACYDwDAfAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA5gMAwHwAAOYDADAfAADmAwAwHwAA5gMAMB8A"
    "gPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwCA+QAAzAcAYD4AAMwHAGA+AADMBwBg"
    "PgAAzAcAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgP"
    "AMB8SAAAmA8AwHwAAJgPAMB8AACYDwDAfAAA5gMAwHwAAOYDAMB8AADmAwDAfAAA5gMAMB8AAOYD"
    "ADAfAADmAwAwHwAA5gMAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwCA+QAA"
    "zAcAYD4AAMwHAGA+AADMBwBgPgAAzAcAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADz"
    "AQCYDwAA8wEAmA8AAPMBAJgPAMB8AACYDwDAfAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA5gMAwHwA"
    "AOYDADAfAADmAwAwHwAA5gMAMB8AgPlQAQAwHwCA+QAAMB8AgPkAADAfAID5AADMBwCA+QAAzAcA"
    "gPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQCY"
    "DwAA8wEAmA8AAPMBAJgPAADzAQCYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYM"
    "AMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAA"
    "zAcAgPkAAMwHAID5AADMBwCA+QAAzAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADz"
    "AQBgPgAA8wEAYD4AAPMBAJgPAADzAQCYDwAA8wEAmA8AwHxIAACYDwDAfAAAmA8AwHwAAJgPAMB8"
    "AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8A"
    "gPkAADAfAID5AAAwHwCA+QAAzAcAgPkAAMwHAID5AADMBwCA+QAAzAcAYD4AAMwHAGA+AADMBwBg"
    "PgAAzAcAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgP"
    "AMB8AACYDwDAfAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA5gMAwHwAAOYDADAfAADmAwAwHwAA5gMA"
    "MB8AAOYDADAfAID5AAAwHwCA+QAAMB8AgPkAADAfAID5AADMBwCA+QAAzAcAgPkAAMwHAID5AADM"
    "BwBgPgAAzAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAmA8AAPMB"
    "AJgPAADzAQCYDwDAfEgAAJgPAMB8AACYDwDAfAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA5gMAwHwA"
    "AOYDADAfAADmAwAwHwAA5gMAMB8AAOYDADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwCA"
    "+QAAzAcAgPkAAMwHAGA+AADMBwBgPgAAzAcAYD4AAMwHAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+"
    "AADzAQCYDwAA8wEAmA8AAPMBAJgPAMB8AACYDwDAfAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA5gMA"
    "wHwAAOYDADAfAADmAwAwHwAA5gMAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADM"
    "BwCA+QAAzAcAYD4AAMwHAGA+AADMBwBgPgAAzAcAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMB"
    "AGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAMB8SAAAmA8AwHwAAJgPAMB8AACYDwDAfAAA5gMAwHwA"
    "AOYDAMB8AADmAwDAfAAA5gMAMB8AAOYDADAfAADmAwAwHwAA5gMAMB8AgPkAADAfAID5AAAwHwCA"
    "+QAAMB8AgPkAAMwHAID5AADMBwCA+QAAzAcAgPkAAMwHAGA+AADMBwBgPgAAzAcAYD4AAMwHAGA+"
    "AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAMB8AACYDwDAfAAAmA8A"
    "wHwAAOYDAMB8AADmAwDAfAAA5gMAwHwAAOYDADAfAADmAwAwHwAA5gMAMB8AgPlQAQAwHwCA+QAA"
    "MB8AgPkAADAfAID5AADMBwCA+QAAzAcAgPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwHAGA+AADM"
    "BwBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAADzAQCYDwDAfAAAmA8AwHwA"
    "AJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA"
    "+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAzAcAgPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwHAGA+"
    "AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAJgPAADzAQCYDwAA8wEAmA8A"
    "wHxIAACYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMA"
    "MB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAzAcAgPkAAMwHAID5AADM"
    "BwCA+QAAzAcAYD4AAMwHAGA+AADMBwBgPgAAzAcAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMB"
    "AGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAMB8AACYDwDAfAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA"
    "5gMAwHwAAOYDADAfAADmAwAwHwAA5gMAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5"
    "AADMBwCA+QAAzAcAYD4AAMwHAGA+AADMBwBgPgAAzAcAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4A"
    "APMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAMB8SAAAmA8AwHwAAJgPAMB8AACYDwDAfAAA5gMA"
    "wHwAAOYDAMB8AADmAwDAfAAA5gMAMB8AAOYDADAfAADmAwAwHwAA5gMAMB8AgPkAADAfAID5AAAw"
    "HwCA+QAAMB8AgPkAAMwHAID5AADMBwCA+QAAzAcAgPkAAMwHAGA+AADMBwBgPgAAzAcAYD4AAMwH"
    "AGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAMB8AACYDwDAfAAA"
    "mA8AwHwAAOYDAMB8AADmAwDAfAAA5gMAwHwAAOYDADAfAADmAwAwHwAA5gMAMB8AgPlQAQAwHwCA"
    "+QAAMB8AgPkAADAfAID5AADMBwCA+QAAzAcAgPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwHAGA+"
    "AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAmA8AAPMBAJgPAADzAQCYDwDAfAAAmA8A"
    "wHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAw"
    "HwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAzAcAgPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwH"
    "AGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAJgPAADzAQCYDwAA8wEA"
    "mA8AwHxIAACYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA"
    "5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAzAcAgPkAAMwHAID5"
    "AADMBwBgPgAAzAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4A"
    "APMBAJgPAADzAQCYDwAA8wEAmA8AwHwAAJgPAMB8AACYDwDAfAAAmA8AwHwAAOYDAMB8AADmAwDA"
    "fAAA5gMAwHwAAOYDADAfAADmAwAwHwAA5gMAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwH"
    "AID5AADMBwCA+QAAzAcAYD4AAMwHAGA+AADMBwBgPgAAzAcAYD4AAPMBAGA+AADzAQBgPgAA8wEA"
    "YD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAMB8SAAAmA8AwHwAAJgPAMB8AACYDwDAfAAA"
    "5gMAwHwAAOYDAMB8AADmAwDAfAAA5gMAMB8AAOYDADAfAADmAwAwHwAA5gMAMB8AgPkAADAfAID5"
    "AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwCA+QAAzAcAYD4AAMwHAGA+AADMBwBgPgAAzAcAYD4A"
    "APMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAMB8AACYDwDA"
    "fAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA5gMAwHwAAOYDADAfAADmAwAwHwAA5gMAMB8AgPlQAQAw"
    "HwCA+QAAMB8AgPkAADAfAID5AADMBwCA+QAAzAcAgPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwH"
    "AGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAmA8AAPMBAJgPAADzAQCYDwDAfAAA"
    "mA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADm"
    "AwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAzAcAgPkAAMwHAID5AADMBwBgPgAAzAcAYD4A"
    "AMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAJgPAADzAQCYDwAA"
    "8wEAmA8AwHxIAACYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAw"
    "HwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAzAcAgPkAAMwH"
    "AID5AADMBwCA+QAAzAcAYD4AAMwHAGA+AADMBwBgPgAAzAcAYD4AAPMBAGA+AADzAQBgPgAA8wEA"
    "YD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAMB8AACYDwDAfAAAmA8AwHwAAOYDAMB8AADm"
    "AwDAfAAA5gMAwHwAAOYDADAfAADmAwAwHwAA5gMAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkA"
    "AMwHAID5AADMBwCA+QAAzAcAgPkAAMwHAGA+AADMBwBgPgAAzAcAYD4AAPMBAGA+AADzAQBgPgAA"
    "8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAMB8SAAAmA8AwHwAAJgPAMB8AACYDwDA"
    "fAAA5gMAwHwAAOYDAMB8AADmAwDAfAAA5gMAMB8AAOYDADAfAADmAwAwHwAA5gMAMB8AgPkAADAf"
    "AID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwCA+QAAzAcAgPkAAMwHAGA+AADMBwBgPgAAzAcA"
    "YD4AAMwHAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAMB8AACY"
    "DwDAfAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA5gMAwHwAAOYDADAfAADmAwAwHwAA5gMAMB8AgPlQ"
    "AQAwHwCA+QAAMB8AgPkAADAfAID5AADMBwCA+QAAzAcAgPkAAMwHAID5AADMBwBgPgAAzAcAYD4A"
    "AMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAADzAQCYDwDA"
    "fAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAf"
    "AADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAzAcAgPkAAMwHAID5AADMBwCA+QAAzAcA"
    "YD4AAMwHAGA+AADMBwBgPgAAzAcAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCY"
    "DwAA8wEAmA8AAPMBAJgPAMB8SAAAmA8AwHwAAJgPAMB8AACYDwDAfAAA5gMAwHwAAOYDAMB8AADm"
    "AwDAfAAA5gMAMB8AAOYDADAfAADmAwAwHwAA5gMAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkA"
    "AMwHAID5AADMBwCA+QAAzAcAgPkAAMwHAGA+AADMBwBgPgAAzAcAYD4AAMwHAGA+AADzAQBgPgAA"
    "8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAMB8AACYDwDAfAAAmA8AwHwAAOYDAMB8"
    "AADmAwDAfAAA5gMAwHwAAOYDADAfAADmAwAwHwAA5gMAMB8AgPlQAQAwHwCA+QAAMB8AgPkAADAf"
    "AID5AADMBwCA+QAAzAcAgPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwHAGA+AADMBwBgPgAA8wEA"
    "YD4AAPMBAGA+AADzAQBgPgAA8wEAmA8AAPMBAJgPAADzAQCYDwDAfAAAmA8AwHwAAJgPAMB8AADm"
    "AwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkA"
    "ADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwHAGA+AADMBwBgPgAA"
    "8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAJgPAADzAQCYDwAA8wEAmA8AwHxIAACYDwDA"
    "fAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAf"
    "AADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAzAcAgPkAAMwHAID5AADMBwCA+QAAzAcA"
    "YD4AAMwHAGA+AADMBwBgPgAAzAcAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCY"
    "DwAA8wEAmA8AAPMBAJgPAMB8AACYDwDAfAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA5gMAwHwAAOYM"
    "AMB8AADmAwAwHwAA5gMAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwCA+QAA"
    "zAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAmA8AAPMBAJgPAADz"
    "AQCYDwAA8wEAmA8AwHxIAACYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8"
    "AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAzAcA"
    "gPkAAMwHAID5AADMBwCA+QAAzAcAYD4AAMwHAGA+AADMBwBgPgAAzAcAYD4AAPMBAGA+AADzAQBg"
    "PgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAMB8AACYDwDAfAAAmA8AwHwAAOYM"
    "AMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAA"
    "zAcAgPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADz"
    "AQBgPgAA8wEAmA8AAPMBAJgPAADzAQCYDwDAfEgAAJgPAMB8AACYDwDAfAAAmA8AwHwAAOYDAMB8"
    "AADmAwDAfAAA5gMAwHwAAOYDADAfAADmAwAwHwAA5gMAMB8AAOYDADAfAID5AAAwHwCA+QAAMB8A"
    "gPkAAMwHAID5AADMBwCA+QAAzAcAgPkAAMwHAGA+AADMBwBgPgAAzAcAYD4AAMwHAGA+AADzAQBg"
    "PgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAMB8AACYDwDAfAAAmA8AwHwAAOYM"
    "AMB8AADmAwDAfAAA5gMAwHwAAOYDADAfAADmAwAwHwAA5gMAMB8AgPlQAQAwHwCA+QAAMB8AgPkA"
    "ADAfAID5AADMBwCA+QAAzAcAgPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwHAGA+AADMBwBgPgAA"
    "8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAmA8AAPMBAJgPAADzAQCYDwDAfAAAmA8AwHwAAJgPAMB8"
    "AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8A"
    "gPkAADAfAID5AAAwHwCA+QAAzAcAgPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwHAGA+AADMBwBg"
    "PgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAmA8AAPMBAJgPAADzAQCYDwDAfEgAAJgPAMB8AACY"
    "DwDAfAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA5gMAwHwAAOYDADAfAADmAwAwHwAA5gMAMB8AAOZD"
    "ADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwCA+QAAzAcAgPkAAMwHAGA+AADMBwBgPgAA"
    "zAcAYD4AAMwHAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAMB8"
    "AACYDwDAfAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA5gMAwHwAAOYDADAfAADmAwAwHwAA5gMAMB8A"
    "gPlQAQAwHwCA+QAAMB8AgPkAADAfAID5AADMBwCA+QAAzAcAgPkAAMwHAID5AADMBwBgPgAAzAcA"
    "YD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAmA8AAPMBAJgPAADzAQCY"
    "DwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOZD"
    "ADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwBgPgAA"
    "zAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAJgPAADz"
    "AQCYDwAA8wEAmA8AwHxIAACYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8"
    "AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAzAcA"
    "gPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBg"
    "PgAA8wEAmA8AAPMBAJgPAADzAQCYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYM"
    "AMB8AADmAwAwHwAA5gMAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwCA+QAA"
    "zAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAmA8AAPMBAJgPAADz"
    "AQCYDwDAfEgAAJgPAMB8AACYDwDAfAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA5gMAwHwAAOYDADAf"
    "AADmAwAwHwAA5gMAMB8AAOYDADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwCA+QAAzAcA"
    "gPkAAMwHAGA+AADMBwBgPgAAzAcAYD4AAMwHAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCY"
    "DwAA8wEAmA8AAPMBAJgPAMB8AACYDwDAfAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA5gMAwHwAAOYM"
    "AMB8AADmAwAwHwAA5gMAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwCA+QAA"
    "zAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAJgPAADz"
    "AQCYDwAA8wEAmA8AwHxIAACYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8"
    "AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAzAcA"
    "gPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBg"
    "PgAA8wEAmA8AAPMBAJgPAADzAQCYDwDAfEgAAJgPAMB8AACYDwDAfAAAmA8AwHwAAOYDAMB8AADm"
    "AwDAfAAA5gMAwHwAAOYDADAfAADmAwAwHwAA5gMAMB8AAOYDADAfAID5AAAwHwCA+QAAMB8AgPkA"
    "AMwHAID5AADMBwCA+QAAzAcAgPkAAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA"
    "8wEAYD4AAPMBAJgPAADzAQCYDwAA8wEAmA8AwHxIAACYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDA"
    "fAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAf"
    "AID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwCA+QAAzAcAgPkAAMwHAGA+AADMBwBgPgAA8wEA"
    "YD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAJgPAADzAQCYDwAA8wEAmA8AwHxIAACYDwDAfAAA"
    "mA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADm"
    "AwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAzAcAgPkAAMwHAID5AADMBwCA+QAAzAcAYD4A"
    "AMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAmA8AAPMBAJgPAADzAQCYDwDA"
    "fEgAAJgPAMB8AACYDwDAfAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA5gMAwHwAAOYDADAfAADmAwAw"
    "HwAA5gMAMB8AAOYDADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwH"
    "AGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAJgPAADzAQCYDwAA8wEA"
    "mA8AwHxIAACYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA"
    "5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAzAcAgPkAAMwHAID5"
    "AADMBwBgPgAAzAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAmA8A"
    "APMBAJgPAADzAQCYDwDAfAAA"
    "mA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADm"
    "AwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwBgPgAAzAcAYD4A"
    "AMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAJgPAADzAQCYDwAA"
    "8wEAmA8AwHxIAACYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAw"
    "HwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwH"
    "AID5AADMBwCA+QAAzAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEA"
    "mA8AAPMBAJgPAADzAQCYDwDAfEgAAJgPAMB8AACYDwDAfAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA"
    "5gMAwHwAAOYDADAfAADmAwAwHwAA5gMAMB8AAOYDADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5"
    "AADMBwCA+QAAzAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4A"
    "APMBAJgPAADzAQCYDwAA8wEAmA8AwHxIAACYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMA"
    "wHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAw"
    "HwCA+QAAMB8AgPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMB"
    "AGA+AADzAQBgPgAA8wEAYD4AAPMBAJgPAADzAQCYDwAA8wEAmA8AwHxIAACYDwDAfAAAmA8AwHwA"
    "AJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA"
    "+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwHAGA+"
    "AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAJgPAADzAQCYDwAA8wEAmA8A"
    "wHxIAACYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMA"
    "MB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADM"
    "BwCA+QAAzAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMB"
    "AJgPAADzAQCYDwAA8wEAmA8AwHxIAACYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwA"
    "AOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA"
    "+QAAzAcAgPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+"
    "AADzAQBgPgAA8wEAYD4AAPMBAJgPAADzAQCYDwAA8wEAmA8AwHxIAACYDwDAfAAAmA8AwHwAAJgP"
    "AMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAA"
    "MB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwCA+QAAzAcAYD4AAMwHAGA+AADz"
    "AQBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAmA8AAPMBAJgPAADzAQCYDwDAfEgAAJgPAMB8"
    "AACYDwDAfAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA5gMAwHwAAOYDADAfAADmAwAwHwAA5gMAMB8A"
    "AOYDADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwCA+QAAzAcAYD4AAMwHAGA+AADMBwBg"
    "PgAAzAcAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgP"
    "AMB8AACYDwDAfAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA5gMAwHwAAOYDADAfAADmAwAwHwAA5gMA"
    "MB8AAOYDADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwCA+QAAzAcAgPkAAMwHAGA+AADz"
    "AQBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAJgPAADzAQCYDwAA8wEAmA8AwHxI"
    "AACYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8A"
    "AOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwBg"
    "PgAAzAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAJgP"
    "AADzAQCYDwAA8wEAmA8AwHxIAACYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYM"
    "AMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAA"
    "MB8AgPkAAMwHAID5AADMBwCA+QAAzAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADz"
    "AQBgPgAA8wEAYD4AAPMBAJgPAADzAQCYDwAA8wEAmA8AwHxIAACYDwDAfAAAmA8AwHwAAJgPAMB8"
    "AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8A"
    "gPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwHAGA+AADMBwBg"
    "PgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAJgPAADzAQCYDwAA8wEAmA8AwHxIAACY"
    "DwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOZD"
    "ADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwBgPgAA"
    "zAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAJgPAADz"
    "AQCYDwAA8wEAmA8AwHxIAACYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8"
    "AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8A"
    "gPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBg"
    "PgAA8wEAYD4AAPMBAJgPAADzAQCYDwAA8wEAmA8AwHxIAACYDwDAfAAAmA8AwHwAAJgPAMB8AADm"
    "AwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkA"
    "ADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwHAGA+AADMBwBgPgAA"
    "8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAJgPAADzAQCYDwAA8wEAmA8AwHxIAACYDwDA"
    "fAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAf"
    "AADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwBgPgAAzAcA"
    "YD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAMB8SAAA"
    "mA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADm"
    "AwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwBgPgAAzAcAYD4A"
    "AMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAJgPAADzAQCYDwAA"
    "8wEAmA8AwHxIAACYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAw"
    "HwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAzAcAgPkAAMwH"
    "AGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAJgPAADzAQCYDwAA8wEA"
    "mA8AwHxIAACYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA"
    "5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5"
    "AADMBwBgPgAAzAcAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8A"
    "APMBAJgPAADzAQCYDwDAfEgAAJgPAMB8AACYDwDAfAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA5gMA"
    "wHwAAOYDADAfAADmAwAwHwAA5gMAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADM"
    "BwBgPgAAzAcAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMB"
    "AJgPAMB8SAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8A"
    "AOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAzAcAgPkAAMwHAID5AADMBwBg"
    "PgAAzAcAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgP"
    "AMB8AACYDwDAfAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA5gMAwHwAAOYDADAfAADmAwAwHwAA5gMA"
    "MB8AgPlQAQAwHwCA+QAAMB8AgPkAADAfAID5AADMBwCA+QAAzAcAgPkAAMwHAID5AADMBwBgPgAA"
    "zAcAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAADz"
    "AQCYDwDAfEgAAJgPAMB8AACYDwDAfAAAmA8AwHwAAOYDAMB8AADmAwDAfAAA5gMAwHwAAOYDADAf"
    "AADmAwAwHwAA5gMAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwCA+QAAzAcA"
    "gPkAAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAJgPAADzAQCY"
    "DwAA8wEAmA8AwHxIAACYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADm"
    "AwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkA"
    "AMwHAID5AADMBwCA+QAAzAcAgPkAAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA"
    "8wEAYD4AAPMBAJgPAADzAQCYDwAA8wEAmA8AwHxIAACYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDA"
    "fAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAf"
    "AID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwCA+QAAzAcAgPkAAMwHAGA+AADMBwBgPgAAzAcA"
    "YD4AAMwHAGA+AADzAQBgPgAA8wEAYD4AAPMBAGA+AADzAQCYDwAA8wEAmA8AAPMBAJgPAMB8SAAA"
    "mA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADm"
    "AwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwCA+QAAzAcAYD4A"
    "AMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAJgPAADzAQCYDwAA"
    "8wEAmA8AwHxIAACYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAw"
    "HwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwH"
    "AID5AADMBwCA+QAAzAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4AAPMBAGA+AADzAQBgPgAA8wEA"
    "YD4AAPMBAJgPAADzAQCYDwAA8wEAmA8AwHxIAACYDwDAfAAAmA8AwHwAAJgPAMB8AADmAwDAfAAA"
    "5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAwHwCA+QAAMB8AgPkAADAfAID5"
    "AAAwHwCA+QAAMB8AgPkAAMwHAID5AADMBwBgPgAAzAcAYD4AAMwHAGA+AADMBwBgPgAA8wEAYD4A"
    "APMBAGA+AADzAQBgPgAA8wEAYD4AAPMBAJgPAADzAQCYDwAA8wEAmA8AwHxIAACYDwDAfAAAmA8A"
    "wHwAAJgPAMB8AADmAwDAfAAA5gMAwHwAAOYDAMB8AADmAwAwHwAA5gMAMB8AAOYDADAfAADmAwAw"
    "HwCA+QAAMB8AgPkAADAfAID5AAAwHwCA+QAAMB8AgPkAAMwHAGD3m6VGg0mo5dwAAAABJRU5ErkJg"
    "gg=="
)
PREVIEW_PNG_BYTES = base64.b64decode(PREVIEW_PNG_BASE64)


# ---------------------------------------------------------------------------
# Parsing `sample_input.md`-style markdown into blocks
# ---------------------------------------------------------------------------


def parse_md_lines(lines: Iterable[str]) -> List[Block]:
    def _normalize_line(raw: str) -> str:
        # 탭 → 스페이스 치환 후 개행 제거
        return raw.replace("\t", "    ").rstrip("\n")

    def _parse_table_block(idx: int, line_list: List[str]) -> tuple[TableBlock | None, int]:
        """현재 인덱스에서 마크다운 표를 파싱한다. 다음 소비할 인덱스까지 반환."""

        title_match = re.match(r"^<\s*표\s*제목\s*:\s*(.+?)>\s*$", line_list[idx].strip())
        if not title_match:
            return None, idx
        title = title_match.group(1).strip()
        table_lines: List[str] = []
        j = idx + 1
        # 제목 다음의 공백/빈 줄은 건너뛴다.
        while j < len(line_list) and not line_list[j].strip():
            j += 1
        while j < len(line_list):
            ln = line_list[j].rstrip("\n")
            if ln.strip().startswith("|"):
                table_lines.append(ln.strip())
                j += 1
                continue
            # 표 블록이 끝났다고 판단
            break

        if len(table_lines) < 2:
            return None, idx

        def _split_row(row: str) -> List[str]:
            cells = row.strip().strip("|").split("|")
            return [c.strip() for c in cells]

        header_cells = _split_row(table_lines[0])
        align_cells = _split_row(table_lines[1])
        body_rows = [_split_row(r) for r in table_lines[2:]]

        def _parse_align(token: str) -> str:
            token = token.strip()
            if token.startswith(":") and token.endswith(":"):
                return "CENTER"
            if token.endswith(":"):
                return "RIGHT"
            if token.startswith(":"):
                return "LEFT"
            return "LEFT"

        aligns = [_parse_align(a) for a in align_cells]
        tbl = TableBlock(
            type=BlockType.TABLE,
            raw="\n".join([line_list[idx]] + table_lines),
            text=title,
            title=title,
            header=header_cells,
            aligns=aligns,
            rows=body_rows,
        )
        return tbl, j

    def _parse_summary_block(idx: int, line_list: List[str]) -> tuple[SummaryTableBlock | None, int]:
        marker = line_list[idx].strip().replace(" ", "")
        if marker not in ("<요약표시작>", "<요약표시작>"):
            return None, idx
        items: List[Block] = []
        j = idx + 1
        while j < len(line_list):
            ln_original = _normalize_line(line_list[j])
            ln = ln_original.lstrip(" ")
            if ln.replace(" ", "") == "<요약표끝>":
                j += 1
                break
            if not ln:
                j += 1
                continue
            if ln.startswith("◦"):
                text = ln[len("◦") :].strip()
                items.append(Block(BlockType.BODY, ln_original, text))
            elif ln.startswith("-"):
                text = ln[len("-") :].strip()
                items.append(Block(BlockType.DESC2, ln_original, text))
            else:
                # 요약표 내부의 기타 라인은 PLAIN으로 유지
                items.append(Block(BlockType.PLAIN, ln_original, ln))
            j += 1
        summ = SummaryTableBlock(
            type=BlockType.SUMMARY_TABLE,
            raw="\n".join(line_list[idx:j]),
            text="요약표",
            items=items,
        )
        return summ, j

    blocks: List[Block] = []
    line_list = [_normalize_line(ln) for ln in lines]
    i = 0
    while i < len(line_list):
        line = line_list[i]
        stripped = line.lstrip(" ")
        leading_spaces = len(line) - len(stripped)

        # 요약표
        summary_block, next_idx = _parse_summary_block(i, line_list)
        if summary_block is not None:
            blocks.append(summary_block)
            i = next_idx
            continue

        # 표
        table_block, next_idx = _parse_table_block(i, line_list)
        if table_block is not None:
            blocks.append(table_block)
            i = next_idx
            continue

        if not stripped:
            blocks.append(Block(BlockType.PLAIN, line, ""))
            i += 1
            continue

        if stripped.startswith("<주제목>"):
            text = stripped[len("<주제목>") :].strip()
            if not text and i + 1 < len(line_list):
                text = line_list[i + 1].strip()
                i += 1
            blocks.append(Block(BlockType.TITLE, line, text))
            i += 1
            continue

        if stripped.startswith("<강조>"):
            text = stripped[len("<강조>") :].strip()
            if not text and i + 1 < len(line_list):
                text = line_list[i + 1].strip()
                i += 1
            blocks.append(Block(BlockType.EMPHASIS, line, text))
            i += 1
            continue

        if stripped.startswith("□"):
            text = stripped[len("□") :].strip()
            blocks.append(Block(BlockType.SUBTITLE, line, text))
            i += 1
            continue

        if stripped.startswith(("◦", "•", "∙", "·")):
            text = stripped[len("◦") :].strip()
            blocks.append(Block(BlockType.BODY, line, text))
            i += 1
            continue

        if stripped.startswith(("-", "–", "—")) and leading_spaces <= 3:
            text = stripped[len(stripped[0]) :].strip()
            blocks.append(Block(BlockType.DESC2, line, text))
            i += 1
            continue

        if stripped.startswith(("*", "●")) and leading_spaces <= 4:
            text = stripped[len(stripped[0]) :].strip()
            blocks.append(Block(BlockType.DESC3, line, text))
            i += 1
            continue

        blocks.append(Block(BlockType.PLAIN, line, stripped))
        i += 1

    return blocks


BOLD_PATTERN = re.compile(r"\*\*(.+?)\*\*")


def _split_bold_segments(text: str) -> List[tuple[str, bool]]:
    segments: List[tuple[str, bool]] = []
    last = 0
    for match in BOLD_PATTERN.finditer(text):
        start, end = match.span()
        if start > last:
            segments.append((text[last:start], False))
        segments.append((match.group(1), True))
        last = end
    if last < len(text):
        segments.append((text[last:], False))
    if not segments and text:
        segments.append((text, False))
    return segments


def _append_text_with_bold(paragraph: ET.Element, base_char_id: str | None, full_text: str) -> None:
    _append_text_with_bold_custom(paragraph, base_char_id, full_text, INLINE_BOLD_CHAR_ID)


def _append_text_with_bold_custom(
    paragraph: ET.Element, base_char_id: str | None, full_text: str, bold_char_id: str
) -> None:
    if full_text is None:
        return
    if not full_text:
        return
    segments = _split_bold_segments(full_text)
    if not segments:
        segments = [(full_text, False)]
    for seg_text, is_bold in segments:
        if not seg_text:
            continue
        run_attrs = {}
        if is_bold:
            run_attrs["charPrIDRef"] = bold_char_id
        elif base_char_id is not None:
            run_attrs["charPrIDRef"] = base_char_id
        run = ET.SubElement(paragraph, _q("hp", "run"), run_attrs)
        t = ET.SubElement(run, _q("hp", "t"))
        t.text = seg_text


def _strip_bold_markup(text: str) -> str:
    if not text:
        return ""
    return BOLD_PATTERN.sub(lambda match: match.group(1), text)


def _format_block_preview_text(block: Block) -> Optional[str]:
    if not block.text:
        return None
    if block.type in (BlockType.TABLE, BlockType.SUMMARY_TABLE):
        return None
    if block.type == BlockType.TITLE:
        return None
    cleaned = _strip_bold_markup(block.text).strip()
    if not cleaned:
        return None
    if block.type == BlockType.SUBTITLE:
        return f"□ {cleaned}"
    if block.type == BlockType.BODY:
        return f" ◦ {cleaned}"
    if block.type == BlockType.DESC2:
        return f"   - {cleaned}"
    if block.type == BlockType.DESC3:
        return f"    * {cleaned}"
    if block.type == BlockType.EMPHASIS:
        return f"◈ {cleaned}"
    return cleaned


def _build_preview_text(blocks: List[Block], title: str) -> str:
    safe_title = title.strip() or "Untitled"
    lines = ["< >", f"<{safe_title}>", "< >", ""]
    for block in blocks:
        preview_line = _format_block_preview_text(block)
        if preview_line is None:
            continue
        lines.append(preview_line)
        lines.append("")
    preview = "\n".join(lines).rstrip()
    if not preview.endswith("\n"):
        preview += "\n"
    return preview


KOREAN_WEEKDAY_NAMES = [
    "월요일",
    "화요일",
    "수요일",
    "목요일",
    "금요일",
    "토요일",
    "일요일",
]


def _format_localized_datetime(local_dt: datetime) -> str:
    weekday = KOREAN_WEEKDAY_NAMES[local_dt.weekday()]
    ampm = "오전" if local_dt.hour < 12 else "오후"
    hour12 = local_dt.hour % 12 or 12
    return (
        f"{local_dt.year}년 {local_dt.month:02d}월 {local_dt.day:02d}일 "
        f"{weekday} {ampm} {hour12}:{local_dt.minute:02d}:{local_dt.second:02d}"
    )


def _isoformat_utc(dt: datetime) -> str:
    return dt.astimezone(timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z")


def _safe_get_username() -> str:
    try:
        return getpass.getuser()
    except Exception:
        return "auto"


def _extract_doc_title(blocks: List[Block]) -> str:
    for block in blocks:
        if block.type == BlockType.TITLE and block.text.strip():
            return _strip_bold_markup(block.text).strip()
    for block in blocks:
        if block.text.strip():
            return _strip_bold_markup(block.text).strip()
    return "Untitled"


def _build_header_footer_text(meta: DocumentMetadata) -> tuple[str, str]:
    """머리말/꼬리말에 넣을 기본 문자열을 구성한다.

    - 머리말: 스타일북의 예시 문구를 그대로 사용하되, 제목 자리에 실제 문서 제목 삽입.
    - 꼬리말: MD에 정의가 없으면 빈 문자열 (현재는 MD 파싱에서 가져오지 않음)
    """

    title = meta.title.strip() or "Untitled"
    header_text = f"추진단 자료 스타일 보고서 - {title}"
    # 꼬리말: MD에 없으므로 빈 문자열
    footer_text = ""
    return header_text, footer_text


def _build_document_metadata(blocks: List[Block]) -> DocumentMetadata:
    title = _extract_doc_title(blocks)
    user = _safe_get_username()
    now_utc = datetime.now(timezone.utc)
    local = now_utc.astimezone()
    return DocumentMetadata(
        title=title,
        creator=user,
        subject=title,
        description=title,
        last_saved_by=user,
        keyword=title,
        created_at=now_utc,
        modified_at=now_utc,
        display_date=_format_localized_datetime(local),
    )


def _attach_secpr(run: ET.Element) -> None:
    sec_pr = ET.SubElement(
        run,
        _q("hp", "secPr"),
        {
            "id": "",
            "textDirection": "HORIZONTAL",
            "spaceColumns": "1134",
            "tabStop": "8000",
            "tabStopVal": "4000",
            "tabStopUnit": "HWPUNIT",
            "outlineShapeIDRef": "1",
            "memoShapeIDRef": "0",
            "textVerticalWidthHead": "0",
            "masterPageCnt": "0",
        },
    )
    ET.SubElement(sec_pr, _q("hp", "grid"), {"lineGrid": "0", "charGrid": "0", "wonggojiFormat": "0"})
    ET.SubElement(
        sec_pr,
        _q("hp", "startNum"),
        {"pageStartsOn": "BOTH", "page": "0", "pic": "0", "tbl": "0", "equation": "0"},
    )
    ET.SubElement(
        sec_pr,
        _q("hp", "visibility"),
        {
            "hideFirstHeader": "0",
            "hideFirstFooter": "0",
            "hideFirstMasterPage": "0",
            "border": "SHOW_ALL",
            "fill": "SHOW_ALL",
            "hideFirstPageNum": "0",
            "hideFirstEmptyLine": "0",
            "showLineNumber": "0",
        },
    )
    ET.SubElement(
        sec_pr,
        _q("hp", "lineNumberShape"),
        {"restartType": "0", "countBy": "0", "distance": "0", "startNumber": "0"},
    )
    page_pr = ET.SubElement(
        sec_pr,
        _q("hp", "pagePr"),
        {
            "landscape": "WIDELY",
            "width": PAGE_WIDTH_HWP,
            "height": PAGE_HEIGHT_HWP,
            "gutterType": "LEFT_ONLY",
        },
    )
    ET.SubElement(
        page_pr,
        _q("hp", "margin"),
        {
            "header": mm_to_hwp(MARGIN_HEADER_MM),
            "footer": mm_to_hwp(MARGIN_FOOTER_MM),
            "gutter": "0",
            "left": mm_to_hwp(MARGIN_LEFT_MM),
            "right": mm_to_hwp(MARGIN_RIGHT_MM),
            "top": mm_to_hwp(MARGIN_TOP_MM),
            "bottom": mm_to_hwp(MARGIN_BOTTOM_MM),
        },
    )
    footnote_pr = ET.SubElement(sec_pr, _q("hp", "footNotePr"))
    ET.SubElement(
        footnote_pr,
        _q("hp", "autoNumFormat"),
        {"type": "DIGIT", "userChar": "", "prefixChar": "", "suffixChar": ")", "supsript": "0"},
    )
    ET.SubElement(
        footnote_pr,
        _q("hp", "noteLine"),
        {"length": "-1", "type": "SOLID", "width": "0.12 mm", "color": "#000000"},
    )
    ET.SubElement(
        footnote_pr,
        _q("hp", "noteSpacing"),
        {"betweenNotes": "283", "belowLine": "567", "aboveLine": "850"},
    )
    ET.SubElement(footnote_pr, _q("hp", "numbering"), {"type": "CONTINUOUS", "newNum": "1"})
    ET.SubElement(
        footnote_pr,
        _q("hp", "placement"),
        {"place": "EACH_COLUMN", "beneathText": "0"},
    )
    endnote_pr = ET.SubElement(sec_pr, _q("hp", "endNotePr"))
    ET.SubElement(
        endnote_pr,
        _q("hp", "autoNumFormat"),
        {"type": "DIGIT", "userChar": "", "prefixChar": "", "suffixChar": ")", "supsript": "0"},
    )
    ET.SubElement(
        endnote_pr,
        _q("hp", "noteLine"),
        {"length": "14692344", "type": "SOLID", "width": "0.12 mm", "color": "#000000"},
    )
    ET.SubElement(
        endnote_pr,
        _q("hp", "noteSpacing"),
        {"betweenNotes": "0", "belowLine": "567", "aboveLine": "850"},
    )
    ET.SubElement(endnote_pr, _q("hp", "numbering"), {"type": "CONTINUOUS", "newNum": "1"})
    ET.SubElement(
        endnote_pr,
        _q("hp", "placement"),
        {"place": "END_OF_DOCUMENT", "beneathText": "0"},
    )
    for border_type in ("BOTH", "EVEN", "ODD"):
        page_border = ET.SubElement(
            sec_pr,
            _q("hp", "pageBorderFill"),
            {
                "type": border_type,
                "borderFillIDRef": "1",
                "textBorder": "PAPER",
                "headerInside": "0",
                "footerInside": "0",
                "fillArea": "PAPER",
            },
        )
        ET.SubElement(
            page_border,
            _q("hp", "offset"),
            {
                "left": mm_to_hwp(PAGE_BORDER_OFFSET_MM),
                "right": mm_to_hwp(PAGE_BORDER_OFFSET_MM),
                "top": mm_to_hwp(PAGE_BORDER_OFFSET_MM),
                "bottom": mm_to_hwp(PAGE_BORDER_OFFSET_MM),
            },
        )
    ctrl = ET.SubElement(run, _q("hp", "ctrl"))
    ET.SubElement(
        ctrl,
        _q("hp", "colPr"),
        {"id": "", "type": "NEWSPAPER", "layout": "LEFT", "colCount": "1", "sameSz": "1", "sameGap": "0"},
    )


def _append_header_footer_ctrl(root: ET.Element, header_text: str, footer_text: str) -> None:
    """Tier1 샘플 패턴을 따르는 머리말/꼬리말 컨트롤을 추가한다.

    - 머리말: 첫 번째 문단(`id="0"`) 안, 제목 테이블(run) 바로 뒤에 header ctrl 삽입.
    - 꼬리말: 첫 번째 SUBTITLE 문단 안, 선행 run 으로 footer ctrl 삽입.
    - 둘 다 오른쪽 정렬 스타일을 사용한다.

    섹션 구조가 예상과 다를 경우에는 조용히 건너뛰도록 방어적으로 동작한다.
    """

    # 1) Header: p id="0" 안의 테이블(run) 뒤에 header ctrl 주입
    first_p = None
    for p in root.findall(_q("hp", "p")):
        first_p = p
        break

    if first_p is not None:
        # 제목 테이블을 담고 있는 run 찾기
        header_run = None
        for run in first_p.findall(_q("hp", "run")):
            tbl = run.find(_q("hp", "tbl"))
            if tbl is not None:
                header_run = run
                break

        if header_run is not None:
            header_ctrl = ET.SubElement(header_run, _q("hp", "ctrl"))
            header_elem = ET.SubElement(
                header_ctrl,
                _q("hp", "header"),
                {
                    "id": "1",
                    "applyPageType": "BOTH",
                },
            )
            header_sublist = ET.SubElement(
                header_elem,
                _q("hp", "subList"),
                {
                    "id": "",
                    "textDirection": "HORIZONTAL",
                    "lineWrap": "BREAK",
                    "vertAlign": "TOP",
                    "linkListIDRef": "0",
                    "linkListNextIDRef": "0",
                    "textWidth": TABLE_WIDTH_HWP,
                    "textHeight": "2834",
                    "hasTextRef": "0",
                    "hasNumRef": "0",
                },
            )
            # Tier1 샘플과 동일한 오른쪽 정렬 스타일을 사용한다.
            # (샘플 기준: paraPrIDRef="8", styleIDRef="0")
            header_p = ET.SubElement(
                header_sublist,
                _q("hp", "p"),
                {
                    "id": "0",
                    "paraPrIDRef": HEADER_PARA_ID,
                    "styleIDRef": HEADER_STYLE_ID,
                    "pageBreak": "0",
                    "columnBreak": "0",
                    "merged": "0",
                },
            )
            header_run_inner = ET.SubElement(
                header_p,
                _q("hp", "run"),
                {"charPrIDRef": HEADER_CHAR_ID},
            )
            # 오른쪽 정렬 시 샘플처럼 앞에 탭을 하나 두어 위치를 맞춘다.
            t = ET.SubElement(header_run_inner, _q("hp", "t"))
            # 탭 요소는 단순 오른쪽 정렬용이므로 상수값 사용
            t.text = ""
            tab = ET.SubElement(
                t,
                _q("hp", "tab"),
                {
                    "width": "39188",
                    "leader": "0",
                    "type": "2",
                },
            )
            # 실제 텍스트는 탭 뒤에 이어붙이기
            t.tail = header_text

    # 2) Footer: 첫 번째 SUBTITLE 문단 안에 footer ctrl run을 prepend
    first_subtitle_p = None
    for p in root.findall(_q("hp", "p")):
        if p.get("paraPrIDRef") == PARA_STYLE_MAP[BlockType.SUBTITLE]:
            first_subtitle_p = p
            break

    if first_subtitle_p is not None:
        # 기존 run 들 앞에 footer ctrl run 을 하나 삽입
        footer_run = ET.Element(
            _q("hp", "run"),
            {"charPrIDRef": FOOTER_CHAR_ID},
        )
        footer_ctrl = ET.SubElement(footer_run, _q("hp", "ctrl"))
        footer_elem = ET.SubElement(
            footer_ctrl,
            _q("hp", "footer"),
            {
                "id": "3",
                "applyPageType": "BOTH",
            },
        )
        footer_sublist = ET.SubElement(
            footer_elem,
            _q("hp", "subList"),
            {
                "id": "",
                "textDirection": "HORIZONTAL",
                "lineWrap": "BREAK",
                "vertAlign": "BOTTOM",
                "linkListIDRef": "0",
                "linkListNextIDRef": "0",
                "textWidth": TABLE_WIDTH_HWP,
                "textHeight": "2834",
                "hasTextRef": "0",
                "hasNumRef": "0",
            },
        )
        # Tier1 샘플과 동일한 꼬리말용 paraPr/스타일을 사용한다.
        # (샘플 기준: paraPrIDRef="9", styleIDRef="0")
        footer_p = ET.SubElement(
            footer_sublist,
            _q("hp", "p"),
            {
                "id": "0",
                "paraPrIDRef": FOOTER_PARA_ID,
                "styleIDRef": FOOTER_STYLE_ID,
                "pageBreak": "0",
                "columnBreak": "0",
                "merged": "0",
            },
        )
        footer_run_inner = ET.SubElement(
            footer_p,
            _q("hp", "run"),
            {"charPrIDRef": FOOTER_CHAR_ID},
        )
        t_footer = ET.SubElement(footer_run_inner, _q("hp", "t"))
        t_footer.text = footer_text

        # 새 run 을 첫 child 로 삽입
        existing = list(first_subtitle_p)
        for child in existing:
            first_subtitle_p.remove(child)
        first_subtitle_p.append(footer_run)
        for child in existing:
            first_subtitle_p.append(child)


def _create_table_row(
    tbl: ET.Element,
    *,
    row_idx: int,
    text: str,
    para_id: str,
    style_id: str,
    char_id: str | None,
    cell_margin: dict,
    cell_height: str,
    border_fill: str,
    has_margin: str,
    p_id: int,
    secpr_attached: bool,
) -> tuple[int, bool]:
    tr = ET.SubElement(tbl, _q("hp", "tr"))
    tc = ET.SubElement(
        tr,
        _q("hp", "tc"),
        {
            "name": "",
            "header": "0",
            "hasMargin": has_margin,
            "protect": "0",
            "editable": "0",
            "dirty": "0",
            "borderFillIDRef": border_fill,
        },
    )
    sub_list = ET.SubElement(
        tc,
        _q("hp", "subList"),
        {
            "id": "",
            "textDirection": "HORIZONTAL",
            "lineWrap": "BREAK",
            "vertAlign": "CENTER",
            "linkListIDRef": "0",
            "linkListNextIDRef": "0",
            "textWidth": "0",
            "textHeight": "0",
            "hasTextRef": "0",
            "hasNumRef": "0",
        },
    )
    p = ET.SubElement(
        sub_list,
        _q("hp", "p"),
        {
            "id": str(p_id),
            "paraPrIDRef": para_id,
            "styleIDRef": style_id,
            "pageBreak": "0",
            "columnBreak": "0",
            "merged": "0",
        },
    )
    _append_text_with_bold(p, char_id, text)
    ET.SubElement(tc, _q("hp", "cellAddr"), {"colAddr": "0", "rowAddr": str(row_idx)})
    ET.SubElement(tc, _q("hp", "cellSpan"), {"colSpan": "1", "rowSpan": "1"})
    ET.SubElement(tc, _q("hp", "cellSz"), {"width": TABLE_WIDTH_HWP, "height": cell_height})
    ET.SubElement(tc, _q("hp", "cellMargin"), cell_margin)
    return p_id + 1, secpr_attached


def _append_title_table(
    parent: ET.Element, block: Block, *, table_id: int, p_id: int, secpr_attached: bool
) -> tuple[int, int, bool]:
    p_wrapper = ET.SubElement(
        parent,
        _q("hp", "p"),
        {
            "id": str(p_id),
            "paraPrIDRef": "0",
            "styleIDRef": "0",
            "pageBreak": "0",
            "columnBreak": "0",
            "merged": "0",
        },
    )
    p_id += 1
    if not secpr_attached:
        run_sec = ET.SubElement(p_wrapper, _q("hp", "run"), {"charPrIDRef": RUN_CHAR_OVERRIDE_MAP[BlockType.PLAIN]})
        _attach_secpr(run_sec)
        secpr_attached = True
    run_tbl = ET.SubElement(p_wrapper, _q("hp", "run"))
    tbl = ET.SubElement(
        run_tbl,
        _q("hp", "tbl"),
        {
            "id": str(table_id),
            "zOrder": str(table_id),
            "numberingType": "TABLE",
            "textWrap": "TOP_AND_BOTTOM",
            "textFlow": "BOTH_SIDES",
            "lock": "0",
            "dropcapstyle": "None",
            "pageBreak": "CELL",
            "repeatHeader": "1",
            "rowCnt": "3",
            "colCnt": "1",
            "cellSpacing": "0",
            "borderFillIDRef": "3",  # 표 외곽 테두리 (SOLID)
            "noAdjust": "0",
        },
    )
    total_height = str(int(TITLE_TABLE_ROW_HEIGHTS[0]) + int(TITLE_BODY_HEIGHT_HWP) + int(TITLE_TABLE_ROW_HEIGHTS[2]))
    ET.SubElement(
        tbl,
        _q("hp", "sz"),
        {"width": TABLE_WIDTH_HWP, "widthRelTo": "ABSOLUTE", "height": total_height, "heightRelTo": "ABSOLUTE", "protect": "0"},
    )
    ET.SubElement(
        tbl,
        _q("hp", "pos"),
        {
            "treatAsChar": "0",
            "affectLSpacing": "0",
            "flowWithText": "1",
            "allowOverlap": "0",
            "holdAnchorAndSO": "0",
            "vertRelTo": "PARA",
            "horzRelTo": "COLUMN",
            "vertAlign": "TOP",
            "horzAlign": "LEFT",
            "vertOffset": "0",
            "horzOffset": "0",
        },
    )
    ET.SubElement(tbl, _q("hp", "outMargin"), {"left": "283", "right": "283", "top": "283", "bottom": "283"})
    ET.SubElement(tbl, _q("hp", "inMargin"), {"left": "510", "right": "510", "top": "141", "bottom": "141"})
    row_specs = [
        {
            "text": " ",
            "para_id": "0",
            "style_id": "0",
            "char_id": TITLE_TABLE_SPACER_CHAR_ID,
            "cell_margin": {"left": "0", "right": "0", "top": "0", "bottom": "0"},
            "cell_height": TITLE_TABLE_ROW_HEIGHTS[0],
            "border_fill": TITLE_TABLE_SPACER_BORDER_ID,
            "has_margin": "0",
        },
        {
            "text": block.text,
            "para_id": PARA_STYLE_MAP[BlockType.TITLE],
            "style_id": STYLE_ID_MAP[BlockType.TITLE],
            "char_id": RUN_CHAR_OVERRIDE_MAP[BlockType.TITLE],
            "cell_margin": {"left": "1417", "right": "1417", "top": "141", "bottom": "141"},
            "cell_height": TITLE_TABLE_ROW_HEIGHTS[1],
            "border_fill": TITLE_TABLE_BODY_BORDER_ID,
            "has_margin": "1",
        },
        {
            "text": " ",
            "para_id": "0",
            "style_id": "0",
            "char_id": TITLE_TABLE_SPACER_CHAR_ID,
            "cell_margin": {"left": "0", "right": "0", "top": "0", "bottom": "0"},
            "cell_height": TITLE_TABLE_ROW_HEIGHTS[2],
            "border_fill": TITLE_TABLE_SPACER_BORDER_ID,
            "has_margin": "0",
        },
    ]
    for idx, spec in enumerate(row_specs):
        p_id, secpr_attached = _create_table_row(
            tbl,
            row_idx=idx,
            text=spec["text"],
            para_id=spec["para_id"],
            style_id=spec["style_id"],
            char_id=spec["char_id"],
            cell_margin=spec["cell_margin"],
            cell_height=spec["cell_height"],
            border_fill=spec["border_fill"],
            has_margin=spec["has_margin"],
            p_id=p_id,
            secpr_attached=secpr_attached,
        )
    return p_id, table_id + 1, secpr_attached


def _append_emphasis_table(
    parent: ET.Element, block: Block, *, table_id: int, p_id: int, secpr_attached: bool
) -> tuple[int, int, bool]:
    p_wrapper = ET.SubElement(
        parent,
        _q("hp", "p"),
        {
            "id": str(p_id),
            "paraPrIDRef": "0",
            "styleIDRef": "0",
            "pageBreak": "0",
            "columnBreak": "0",
            "merged": "0",
        },
    )
    p_id += 1
    if not secpr_attached:
        run_sec = ET.SubElement(p_wrapper, _q("hp", "run"), {"charPrIDRef": RUN_CHAR_OVERRIDE_MAP[BlockType.PLAIN]})
        _attach_secpr(run_sec)
        secpr_attached = True
    run_tbl = ET.SubElement(p_wrapper, _q("hp", "run"))
    tbl = ET.SubElement(
        run_tbl,
        _q("hp", "tbl"),
        {
            "id": str(table_id),
            "zOrder": str(table_id),
            "numberingType": "TABLE",
            "textWrap": "TOP_AND_BOTTOM",
            "textFlow": "BOTH_SIDES",
            "lock": "0",
            "dropcapstyle": "None",
            "pageBreak": "CELL",
            "repeatHeader": "1",
            "rowCnt": "1",
            "colCnt": "1",
            "cellSpacing": "0",
            "borderFillIDRef": "3",  # 표 외곽 테두리 (SOLID)
            "noAdjust": "0",
        },
    )
    ET.SubElement(
        tbl,
        _q("hp", "sz"),
        {"width": TABLE_WIDTH_HWP, "widthRelTo": "ABSOLUTE", "height": EMPH_TABLE_HEIGHT_HWP, "heightRelTo": "ABSOLUTE", "protect": "0"},
    )
    ET.SubElement(
        tbl,
        _q("hp", "pos"),
        {
            "treatAsChar": "0",
            "affectLSpacing": "0",
            "flowWithText": "1",
            "allowOverlap": "0",
            "holdAnchorAndSO": "0",
            "vertRelTo": "PARA",
            "horzRelTo": "COLUMN",
            "vertAlign": "TOP",
            "horzAlign": "LEFT",
            "vertOffset": "0",
            "horzOffset": "0",
        },
    )
    ET.SubElement(tbl, _q("hp", "outMargin"), {"left": "283", "right": "283", "top": "283", "bottom": "283"})
    ET.SubElement(tbl, _q("hp", "inMargin"), {"left": "510", "right": "510", "top": "141", "bottom": "141"})
    text = f"◈ {block.text}"
    p_id, secpr_attached = _create_table_row(
        tbl,
        row_idx=0,
        text=text,
        para_id=PARA_STYLE_MAP[BlockType.EMPHASIS],
        style_id=STYLE_ID_MAP[BlockType.EMPHASIS],
        char_id=RUN_CHAR_OVERRIDE_MAP[BlockType.EMPHASIS],
        cell_margin={"left": "566", "right": "566", "top": "566", "bottom": "566"},
        cell_height=EMPH_TABLE_ROW_HEIGHT,
        border_fill=EMPH_TABLE_BORDER_ID,
        has_margin="1",
        p_id=p_id,
        secpr_attached=secpr_attached,
    )
    return p_id, table_id + 1, secpr_attached


def _append_markdown_table(
    parent: ET.Element, block: TableBlock, *, table_id: int, p_id: int, secpr_attached: bool
) -> tuple[int, int, bool]:
    """일반 마크다운 표를 생성한다."""

    col_cnt = max(len(block.header), max((len(r) for r in block.rows), default=0))
    if col_cnt == 0:
        return p_id, table_id, secpr_attached

    # 표 제목 앞 spacer (4pt) 확보
    p_sp = ET.SubElement(
        parent,
        _q("hp", "p"),
        {
            "id": str(p_id),
            "paraPrIDRef": "0",
            "styleIDRef": "0",
            "pageBreak": "0",
            "columnBreak": "0",
            "merged": "0",
        },
    )
    run_sp = ET.SubElement(p_sp, _q("hp", "run"), {"charPrIDRef": "4"})
    t_sp = ET.SubElement(run_sp, _q("hp", "t"))
    t_sp.text = " "
    p_id += 1

    # 표 제목
    if block.title:
        p_title = ET.SubElement(
            parent,
            _q("hp", "p"),
            {
                "id": str(p_id),
                "paraPrIDRef": TABLE_TITLE_PARA_ID,
                "styleIDRef": TABLE_TITLE_STYLE_ID,
                "pageBreak": "0",
                "columnBreak": "0",
                "merged": "0",
            },
        )
        _append_text_with_bold_custom(p_title, "7", f"< {block.title} >", "13")
        p_id += 1

    # 표 wrapper
    p_wrapper = ET.SubElement(
        parent,
        _q("hp", "p"),
        {
            "id": str(p_id),
            "paraPrIDRef": "0",
            "styleIDRef": "0",
            "pageBreak": "0",
            "columnBreak": "0",
            "merged": "0",
        },
    )
    p_id += 1
    if not secpr_attached:
        run_sec = ET.SubElement(p_wrapper, _q("hp", "run"), {"charPrIDRef": RUN_CHAR_OVERRIDE_MAP[BlockType.PLAIN]})
        _attach_secpr(run_sec)
        secpr_attached = True

    run_tbl = ET.SubElement(p_wrapper, _q("hp", "run"))
    tbl = ET.SubElement(
        run_tbl,
        _q("hp", "tbl"),
        {
            "id": str(table_id),
            "zOrder": str(table_id),
            "numberingType": "TABLE",
            "textWrap": "TOP_AND_BOTTOM",
            "textFlow": "BOTH_SIDES",
            "lock": "0",
            "dropcapstyle": "None",
            "pageBreak": "CELL",
            "repeatHeader": "1",
            "rowCnt": str(len(block.rows) + 1),
            "colCnt": str(col_cnt),
            "cellSpacing": "0",
            "borderFillIDRef": "1",
            "noAdjust": "0",
        },
    )
    row_height = int(TITLE_BODY_HEIGHT_HWP)
    total_height = str(row_height * (len(block.rows) + 1))
    ET.SubElement(
        tbl,
        _q("hp", "sz"),
        {"width": TABLE_WIDTH_HWP, "widthRelTo": "ABSOLUTE", "height": total_height, "heightRelTo": "ABSOLUTE", "protect": "0"},
    )
    ET.SubElement(
        tbl,
        _q("hp", "pos"),
        {
            "treatAsChar": "0",
            "affectLSpacing": "0",
            "flowWithText": "1",
            "allowOverlap": "0",
            "holdAnchorAndSO": "0",
            "vertRelTo": "PARA",
            "horzRelTo": "COLUMN",
            "vertAlign": "TOP",
            "horzAlign": "LEFT",
            "vertOffset": "0",
            "horzOffset": "0",
        },
    )
    ET.SubElement(tbl, _q("hp", "outMargin"), {"left": "283", "right": "283", "top": "283", "bottom": "283"})
    ET.SubElement(tbl, _q("hp", "inMargin"), {"left": "510", "right": "510", "top": "141", "bottom": "141"})

    # 열 너비 계산 (균등 분할)
    total_width = int(TABLE_WIDTH_HWP)
    base_width = total_width // col_cnt
    col_widths = [base_width for _ in range(col_cnt)]
    remainder = total_width - base_width * col_cnt
    if remainder > 0:
        col_widths[-1] += remainder

    # 테이블 테두리 ID (CONFIG에서 가져오기, 없으면 기본값)
    if CONFIG.tables and CONFIG.tables.borders:
        _tb = CONFIG.tables.borders
        TABLE_HEADER_BORDERS = tuple(str(x) for x in _tb.header)
        TABLE_BODY_TOP_BORDERS = tuple(str(x) for x in _tb.body_top)
        TABLE_BODY_MIDDLE_BORDERS = tuple(str(x) for x in _tb.body_middle)
        TABLE_BODY_BOTTOM_BORDERS = tuple(str(x) for x in _tb.body_bottom)
    else:
        TABLE_HEADER_BORDERS = ("12", "13", "14")
        TABLE_BODY_TOP_BORDERS = ("9", "10", "11")
        TABLE_BODY_MIDDLE_BORDERS = ("4", "3", "5")
        TABLE_BODY_BOTTOM_BORDERS = ("6", "7", "8")

    def _pick_border_id(border_ids: tuple[str, str, str], col_idx: int) -> str:
        left_id, mid_id, right_id = border_ids
        if col_cnt == 1:
            return mid_id
        if col_idx == 0:
            return left_id
        if col_idx == col_cnt - 1:
            return right_id
        return mid_id

    def _body_border_for_row(row_idx: int) -> tuple[str, str, str]:
        """본문 행의 위치에 따라 적절한 borderFill ID 튜플 반환.
        
        Pattern (inputmodel 분석 결과):
        - 헤더 바로 다음 행 (body_idx=0): TOP (9,10,11) - 상단 이중선
        - 본문 마지막 행: BOTTOM (6,7,8) - 하단 굵은 실선
        - 본문 중간 행: MIDDLE (4,3,5) - 일반 실선
        - 본문 1행만 있는 경우: TOP 우선 (헤더 아래 이중선 필요)
        """
        body_rows = len(block.rows)
        if body_rows == 0:
            return TABLE_BODY_BOTTOM_BORDERS
        if body_rows == 1:
            # 본문 1행만: 헤더 바로 다음이므로 TOP 사용 (이중선)
            return TABLE_BODY_TOP_BORDERS
        body_idx = row_idx - 1
        if body_idx == 0:
            return TABLE_BODY_TOP_BORDERS
        if body_idx == body_rows - 1:
            return TABLE_BODY_BOTTOM_BORDERS
        return TABLE_BODY_MIDDLE_BORDERS

    cell_margin_attrs = {"left": "510", "right": "510", "top": "141", "bottom": "141"}

    def _add_row(row_cells: List[str], *, is_header: bool, row_idx: int, border_ids: tuple[str, str, str], p_counter: int) -> int:
        tr = ET.SubElement(tbl, _q("hp", "tr"))
        padded = list(row_cells) + [""] * (col_cnt - len(row_cells))
        for col_idx, cell_text in enumerate(padded[:col_cnt]):
            border_fill = _pick_border_id(border_ids, col_idx)
            tc = ET.SubElement(
                tr,
                _q("hp", "tc"),
                {
                    "name": "",
                    "header": "0",
                    "hasMargin": "0",
                    "protect": "0",
                    "editable": "0",
                    "dirty": "0",
                    "borderFillIDRef": border_fill,
                },
            )
            sub_list = ET.SubElement(
                tc,
                _q("hp", "subList"),
                {
                    "id": "",
                    "textDirection": "HORIZONTAL",
                    "lineWrap": "BREAK",
                    "vertAlign": "CENTER",
                    "linkListIDRef": "0",
                    "linkListNextIDRef": "0",
                    "textWidth": "0",
                    "textHeight": "0",
                    "hasTextRef": "0",
                    "hasNumRef": "0",
                },
            )
            p = ET.SubElement(
                sub_list,
                _q("hp", "p"),
                {
                    "id": str(p_counter),
                    "paraPrIDRef": TABLE_HEADER_PARA_ID if is_header else TABLE_BODY_PARA_ID,
                    "styleIDRef": TABLE_HEADER_STYLE_ID if is_header else TABLE_BODY_STYLE_ID,
                    "pageBreak": "0",
                    "columnBreak": "0",
                    "merged": "0",
                },
            )
            char_id = TABLE_HEADER_CHAR_ID if is_header else TABLE_BODY_CHAR_ID
            bold_id = TABLE_HEADER_CHAR_ID if is_header else TABLE_BODY_CHAR_ID
            _append_text_with_bold_custom(p, char_id, cell_text, bold_id)
            ET.SubElement(tc, _q("hp", "cellAddr"), {"colAddr": str(col_idx), "rowAddr": str(row_idx)})
            ET.SubElement(tc, _q("hp", "cellSpan"), {"colSpan": "1", "rowSpan": "1"})
            ET.SubElement(tc, _q("hp", "cellSz"), {"width": str(col_widths[col_idx]), "height": str(row_height)})
            ET.SubElement(
                tc,
                _q("hp", "cellMargin"),
                cell_margin_attrs,
            )
            p_counter += 1
        return p_counter

    p_counter = p_id
    p_counter = _add_row(block.header, is_header=True, row_idx=0, border_ids=TABLE_HEADER_BORDERS, p_counter=p_counter)
    for idx, row in enumerate(block.rows):
        row_idx = idx + 1
        border_ids = _body_border_for_row(row_idx)
        p_counter = _add_row(row, is_header=False, row_idx=row_idx, border_ids=border_ids, p_counter=p_counter)

    return p_counter, table_id + 1, secpr_attached


def _append_summary_table(
    parent: ET.Element, block: SummaryTableBlock, *, table_id: int, p_id: int, secpr_attached: bool
) -> tuple[int, int, bool]:
    """요약표 블록을 표 형태로 렌더링한다."""

    if not block.items:
        return p_id, table_id, secpr_attached

    p_wrapper = ET.SubElement(
        parent,
        _q("hp", "p"),
        {
            "id": str(p_id),
            "paraPrIDRef": "0",
            "styleIDRef": "0",
            "pageBreak": "0",
            "columnBreak": "0",
            "merged": "0",
        },
    )
    p_id += 1
    if not secpr_attached:
        run_sec = ET.SubElement(p_wrapper, _q("hp", "run"), {"charPrIDRef": RUN_CHAR_OVERRIDE_MAP[BlockType.PLAIN]})
        _attach_secpr(run_sec)
        secpr_attached = True

    run_tbl = ET.SubElement(p_wrapper, _q("hp", "run"))
    tbl = ET.SubElement(
        run_tbl,
        _q("hp", "tbl"),
        {
            "id": str(table_id),
            "zOrder": str(table_id),
            "numberingType": "TABLE",
            "textWrap": "TOP_AND_BOTTOM",
            "textFlow": "BOTH_SIDES",
            "lock": "0",
            "dropcapstyle": "None",
            "pageBreak": "CELL",
            "repeatHeader": "1",
            "rowCnt": "1",
            "colCnt": "1",
            "cellSpacing": "0",
            "borderFillIDRef": SUMMARY_TABLE_BORDER_ID,
            "noAdjust": "0",
        },
    )
    row_height = int(TITLE_BODY_HEIGHT_HWP)
    total_height = str(row_height * len(block.items))
    ET.SubElement(
        tbl,
        _q("hp", "sz"),
        {"width": TABLE_WIDTH_HWP, "widthRelTo": "ABSOLUTE", "height": total_height, "heightRelTo": "ABSOLUTE", "protect": "0"},
    )
    ET.SubElement(
        tbl,
        _q("hp", "pos"),
        {
            "treatAsChar": "0",
            "affectLSpacing": "0",
            "flowWithText": "1",
            "allowOverlap": "0",
            "holdAnchorAndSO": "0",
            "vertRelTo": "PARA",
            "horzRelTo": "COLUMN",
            "vertAlign": "TOP",
            "horzAlign": "LEFT",
            "vertOffset": "0",
            "horzOffset": "0",
        },
    )
    ET.SubElement(tbl, _q("hp", "outMargin"), {"left": "283", "right": "283", "top": "283", "bottom": "283"})
    ET.SubElement(
        tbl,
        _q("hp", "inMargin"),
        {"left": mm_to_hwp(5.0), "right": mm_to_hwp(5.0), "top": mm_to_hwp(2.0), "bottom": mm_to_hwp(2.0)},
    )

    p_counter = p_id
    tr = ET.SubElement(tbl, _q("hp", "tr"))
    tc = ET.SubElement(
        tr,
        _q("hp", "tc"),
        {
            "name": "",
            "header": "0",
            "hasMargin": "1",
            "protect": "0",
            "editable": "0",
            "dirty": "0",
            "borderFillIDRef": SUMMARY_TABLE_BORDER_ID,
        },
    )
    sub_list = ET.SubElement(
        tc,
        _q("hp", "subList"),
        {
            "id": "",
            "textDirection": "HORIZONTAL",
            "lineWrap": "BREAK",
            "vertAlign": "CENTER",
            "linkListIDRef": "0",
            "linkListNextIDRef": "0",
            "textWidth": "0",
            "textHeight": "0",
            "hasTextRef": "0",
            "hasNumRef": "0",
        },
    )

    for idx, item in enumerate(block.items):
        # 첫 번째 항목이 아니면 줄간격용 빈 줄 추가 (맑은 고딕 4pt, space 1칸)
        if idx > 0:
            spacer_p = ET.SubElement(
                sub_list,
                _q("hp", "p"),
                {
                    "id": str(p_counter),
                    "paraPrIDRef": "0",
                    "styleIDRef": "0",
                    "pageBreak": "0",
                    "columnBreak": "0",
                    "merged": "0",
                },
            )
            spacer_run = ET.SubElement(spacer_p, _q("hp", "run"), {"charPrIDRef": "3"})  # 맑은 고딕 4pt
            spacer_t = ET.SubElement(spacer_run, _q("hp", "t"))
            spacer_t.text = " "
            p_counter += 1

        para_pr = SUMMARY_BODY_PARA_ID if item.type == BlockType.BODY else SUMMARY_DESC_PARA_ID
        style_pr = SUMMARY_BODY_STYLE_ID if item.type == BlockType.BODY else SUMMARY_DESC_STYLE_ID
        char_id = "7" if item.type == BlockType.BODY else TABLE_BODY_CHAR_ID
        bold_id = "13" if item.type == BlockType.BODY else "12"
        
        # 출력 텍스트: 본문은 ◦, 설명은 - 붙임
        if item.type == BlockType.BODY:
            display_text = f"◦ {item.text}"
        else:
            display_text = f"- {item.text}"
        
        p = ET.SubElement(
            sub_list,
            _q("hp", "p"),
            {
                "id": str(p_counter),
                "paraPrIDRef": para_pr,
                "styleIDRef": style_pr,
                "pageBreak": "0",
                "columnBreak": "0",
                "merged": "0",
            },
        )
        _append_text_with_bold_custom(p, char_id, display_text, bold_id)
        p_counter += 1

    ET.SubElement(tc, _q("hp", "cellAddr"), {"colAddr": "0", "rowAddr": "0"})
    ET.SubElement(tc, _q("hp", "cellSpan"), {"colSpan": "1", "rowSpan": "1"})
    ET.SubElement(tc, _q("hp", "cellSz"), {"width": TABLE_WIDTH_HWP, "height": str(row_height * max(1, len(block.items)))})
    ET.SubElement(
        tc,
        _q("hp", "cellMargin"),
        {"left": mm_to_hwp(5.0), "right": mm_to_hwp(5.0), "top": mm_to_hwp(2.0), "bottom": mm_to_hwp(2.0)},
    )

    return p_counter, table_id + 1, secpr_attached
def mm_to_hwp(mm: float) -> str:
    """Convert millimeters to Hangul internal HWPUNIT."""

    return str(int(mm * HWPUNITS_PER_MM))


NS = {
    "ha": "http://www.hancom.co.kr/hwpml/2011/app",
    "hp": "http://www.hancom.co.kr/hwpml/2011/paragraph",
    "hp10": "http://www.hancom.co.kr/hwpml/2016/paragraph",
    "hs": "http://www.hancom.co.kr/hwpml/2011/section",
    "hc": "http://www.hancom.co.kr/hwpml/2011/core",
    "hh": "http://www.hancom.co.kr/hwpml/2011/head",
    "hhs": "http://www.hancom.co.kr/hwpml/2011/history",
    "hm": "http://www.hancom.co.kr/hwpml/2011/master-page",
    "hpf": "http://www.hancom.co.kr/schema/2011/hpf",
    "hwpunitchar": "http://www.hancom.co.kr/hwpml/2016/HwpUnitChar",
    "ooxmlchart": "http://www.hancom.co.kr/hwpml/2016/ooxmlchart",
    "dc": "http://purl.org/dc/elements/1.1/",
    "opf": "http://www.idpf.org/2007/opf/",
    "epub": "http://www.idpf.org/2007/ops",
    "config": "urn:oasis:names:tc:opendocument:xmlns:config:1.0",
    "ocf": "urn:oasis:names:tc:opendocument:xmlns:container",
    "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    "pkg": "http://www.hancom.co.kr/hwpml/2016/meta/pkg#",
}

# Register all namespace prefixes to avoid ns0, ns1, etc.
for prefix, uri in NS.items():
    ET.register_namespace(prefix, uri)

# Additional namespaces
ET.register_namespace("hv", "http://www.hancom.co.kr/hwpml/2011/version")
ET.register_namespace("odf", "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0")


def _q(prefix: str, tag: str) -> str:
    """Qualified tag helper: _q("hp", "p") → '{ns}p'."""

    return f"{{{NS[prefix]}}}{tag}"


# ---------------------------------------------------------------------------
# Minimal HWPX XML builders (header.xml, section0.xml, content.hpf, container)
# ---------------------------------------------------------------------------


def build_header_xml() -> bytes:
    """header.xml (head/refList) 빌더.

    - style_textbook에서 사용하는 글꼴/문단/스타일 정의를 포함한다.
    - 머리말/꼬리말용 별도 스타일은 아직 두지 않고, 기본 PLAIN 스타일을 재사용한다.
    """

    head = ET.Element(
        _q("hh", "head"),
        {
            "version": "1.4",
            "secCnt": "1",
            "xmlns:ha": NS["ha"],
            "xmlns:hp": NS["hp"],
            "xmlns:hp10": NS["hp10"],
            "xmlns:hs": NS["hs"],
            "xmlns:hc": NS["hc"],
            "xmlns:hh": NS["hh"],
            "xmlns:hhs": NS["hhs"],
            "xmlns:hm": NS["hm"],
            "xmlns:hpf": NS["hpf"],
            "xmlns:dc": NS["dc"],
            "xmlns:opf": NS["opf"],
            "xmlns:ooxmlchart": NS["ooxmlchart"],
            "xmlns:hwpunitchar": NS["hwpunitchar"],
            "xmlns:epub": NS["epub"],
            "xmlns:config": NS["config"],
        },
    )

    # beginNum: 최소 번호 설정
    ET.SubElement(
        head,
        _q("hh", "beginNum"),
        {"page": "1", "footnote": "1", "endnote": "1", "pic": "1", "tbl": "1", "equation": "1"},
    )

    ref_list = ET.SubElement(head, _q("hh", "refList"))

    # fontfaces: 7개 언어 전부 정의 (CRITICAL - Hangul requires all 7 languages)
    # style_textbook에서 실제로 사용하는 글꼴만 정의:
    # - id=0: HY헤드라인M
    # - id=1: 휴먼명조
    # - id=2: 맑은 고딕
    fontfaces = ET.SubElement(ref_list, _q("hh", "fontfaces"), {"itemCnt": "7"})

    def _add_font(ff_parent, font_id: int, face: str) -> None:
        font = ET.SubElement(
            ff_parent,
            _q("hh", "font"),
            {"id": str(font_id), "face": face, "type": "TTF", "isEmbedded": "0"},
        )
        ET.SubElement(
            font,
            _q("hh", "typeInfo"),
            {
                "familyType": "FCAT_GOTHIC",
                "weight": "5",
                "proportion": "3",
                "contrast": "2",
                "strokeVariation": "0",
                "armStyle": "0",
                "letterform": "2",
                "midline": "0",
                "xHeight": "4",
            },
        )

    def add_fontface(lang: str) -> None:
        ff = ET.SubElement(fontfaces, _q("hh", "fontface"), {"lang": lang, "fontCnt": "3"})
        _add_font(ff, 0, "HY헤드라인M")
        _add_font(ff, 1, "휴먼명조")
        _add_font(ff, 2, "맑은 고딕")

    # 7개 언어 모두 추가
    for lang in ["HANGUL", "LATIN", "HANJA", "JAPANESE", "OTHER", "SYMBOL", "USER"]:
        add_fontface(lang)

    # borderFills: YAML 설정에서 로드 (HWPX_IMPLEMENTATION_NOTES.md 규칙 준수)
    # ⚠️ ID 1은 반드시 색없음 (fillBrush 태그 생략)
    # ⚠️ ID는 1부터 시작, 연속 사용 필수
    border_fills = ET.SubElement(ref_list, _q("hh", "borderFills"), {"itemCnt": "0"})
    border_fill_count = 0

    def add_border_fill_from_yaml(bf_def) -> None:
        """YAML의 BorderFillDef를 XML로 변환."""
        nonlocal border_fill_count
        bf = ET.SubElement(
            border_fills,
            _q("hh", "borderFill"),
            {
                "id": str(bf_def.id),
                "threeD": "0",
                "shadow": "0",
                "centerLine": "NONE",
                "breakCellSeparateLine": "0",
            },
        )
        ET.SubElement(bf, _q("hh", "slash"), {"type": "NONE", "Crooked": "0", "isCounter": "0"})
        ET.SubElement(bf, _q("hh", "backSlash"), {"type": "NONE", "Crooked": "0", "isCounter": "0"})
        
        # 테두리 설정
        def _add_edge(tag: str) -> None:
            if bf_def.borders and tag in bf_def.borders:
                typ, width = bf_def.borders[tag]
            else:
                typ, width = "NONE", "0.1 mm"
            ET.SubElement(bf, _q("hh", f"{tag}Border"), {"type": typ, "width": width, "color": "#000000"})
        
        _add_edge("left")
        _add_edge("right")
        _add_edge("top")
        _add_edge("bottom")
        ET.SubElement(bf, _q("hh", "diagonal"), {"type": "SOLID", "width": "0.1 mm", "color": "#000000"})
        
        # 채우기 설정 (fill이 있을 때만 fillBrush 추가)
        # ⚠️ ID 1은 fill=null이어야 함 → fillBrush 태그 없음
        if bf_def.fill is not None:
            face_color = bf_def.fill.get("face_color", "none")
            hatch_color = bf_def.fill.get("hatch_color", "#000000")
            brush = ET.SubElement(bf, _q("hc", "fillBrush"))
            ET.SubElement(brush, _q("hc", "winBrush"), {
                "faceColor": face_color,
                "hatchColor": hatch_color,
                "alpha": "0",
            })
        
        border_fill_count += 1

    # YAML에서 borderFills 로드 (ID 순서대로)
    for bf_def in sorted(CONFIG.border_fills, key=lambda x: x.id):
        add_border_fill_from_yaml(bf_def)

    border_fills.set("itemCnt", str(border_fill_count))

    # charProperties: 글자 모양 정의 (style_textbook 기준)
    char_props = ET.SubElement(ref_list, _q("hh", "charProperties"), {"itemCnt": "0"})

    def add_char_pr(char_id: int, height: int, hangul_font_id: int, *, bold: bool = False) -> None:
        char = ET.SubElement(
            char_props,
            _q("hh", "charPr"),
            {
                "id": str(char_id),
                "height": str(height),
                "textColor": "#000000",
                "shadeColor": "none",
                "useFontSpace": "0",
                "useKerning": "0",
                "symMark": "NONE",
                "borderFillIDRef": "2",
            },
        )
        ET.SubElement(
            char,
            _q("hh", "fontRef"),
            {
                "hangul": str(hangul_font_id),
                "latin": str(hangul_font_id),
                "hanja": str(hangul_font_id),
                "japanese": str(hangul_font_id),
                "other": str(hangul_font_id),
                "symbol": str(hangul_font_id),
                "user": str(hangul_font_id),
            },
        )
        ET.SubElement(
            char,
            _q("hh", "ratio"),
            {
                "hangul": "100",
                "latin": "100",
                "hanja": "100",
                "japanese": "100",
                "other": "100",
                "symbol": "100",
                "user": "100",
            },
        )
        ET.SubElement(
            char,
            _q("hh", "spacing"),
            {
                "hangul": "0",
                "latin": "0",
                "hanja": "0",
                "japanese": "0",
                "other": "0",
                "symbol": "0",
                "user": "0",
            },
        )
        ET.SubElement(
            char,
            _q("hh", "relSz"),
            {
                "hangul": "100",
                "latin": "100",
                "hanja": "100",
                "japanese": "100",
                "other": "100",
                "symbol": "100",
                "user": "100",
            },
        )
        ET.SubElement(
            char,
            _q("hh", "offset"),
            {
                "hangul": "0",
                "latin": "0",
                "hanja": "0",
                "japanese": "0",
                "other": "0",
                "symbol": "0",
                "user": "0",
            },
        )
        ET.SubElement(
            char,
            _q("hh", "underline"),
            {"type": "NONE", "shape": "SOLID", "color": "#000000"},
        )
        ET.SubElement(char, _q("hh", "strikeout"), {"shape": "NONE", "color": "#000000"})
        ET.SubElement(char, _q("hh", "outline"), {"type": "NONE"})
        ET.SubElement(
            char,
            _q("hh", "shadow"),
            {"type": "NONE", "color": "#B2B2B2", "offsetX": "10", "offsetY": "10"},
        )
        if bold:
            ET.SubElement(char, _q("hh", "bold"))

    char_defs = [
        (0, 1500, 1, False),   # 본문 휴먼명조 15pt
        (1, 1000, 2, False),   # spacer 10pt
        (2, 800, 2, False),    # spacer 8pt
        (3, 600, 2, False),    # spacer 6pt
        (4, 400, 2, False),    # spacer 4pt
        (5, 1500, 0, True),    # 주제목 HY 15pt Bold
        (6, 1500, 0, False),   # 소제목 HY 15pt
        (7, 1200, 2, False),   # 설명3 맑은고딕 12pt
        (8, 1500, 1, True),    # 강조 휴먼 15pt Bold
        (9, 100, 2, False),    # 1pt filler
        (10, 1300, 1, False),  # 머리말/꼬리말 휴먼명조 13pt
        (11, 1100, 2, False),  # 표 본문 맑은고딕 11pt
        (12, 1100, 2, True),   # 표 헤더 맑은고딕 11pt Bold
        (13, 1200, 2, True),   # 표/요약표 볼드 맑은고딕 12pt
    ]
    for cid, height, font_id, is_bold in char_defs:
        add_char_pr(cid, height, font_id, bold=is_bold)
    char_props.set("itemCnt", str(len(char_defs)))

    # tabProperties: 3개 (참조 파일 기준)
    tab_props = ET.SubElement(ref_list, _q("hh", "tabProperties"), {"itemCnt": "3"})
    ET.SubElement(tab_props, _q("hh", "tabPr"), {"id": "0", "autoTabLeft": "0", "autoTabRight": "0"})
    ET.SubElement(tab_props, _q("hh", "tabPr"), {"id": "1", "autoTabLeft": "1", "autoTabRight": "0"})
    ET.SubElement(tab_props, _q("hh", "tabPr"), {"id": "2", "autoTabLeft": "0", "autoTabRight": "1"})

    # paraProperties: 문단 모양 정의 (id 0 = 기본, 나머지는 BlockType/여백용)
    para_props = ET.SubElement(ref_list, _q("hh", "paraProperties"), {"itemCnt": "0"})

    def add_para_pr(
        para_id: int,
        horizontal_align: str,
        line_spacing_value: int,
        *,
        font_line_height: str = "0",
        snap_to_grid: str = "1",
        margin: Optional[dict] = None,
        border_fill_id: str = "1",
    ) -> None:
        para = ET.SubElement(
            para_props,
            _q("hh", "paraPr"),
            {
                "id": str(para_id),
                "tabPrIDRef": "0",
                "condense": "0",
                "fontLineHeight": font_line_height,
                "snapToGrid": snap_to_grid,
                "suppressLineNumbers": "0",
                "checked": "0",
            },
        )
        ET.SubElement(
            para,
            _q("hh", "align"),
            {"horizontal": horizontal_align, "vertical": "BASELINE"},
        )
        ET.SubElement(para, _q("hh", "heading"), {"type": "NONE", "idRef": "0", "level": "0"})
        ET.SubElement(
            para,
            _q("hh", "breakSetting"),
            {
                "breakLatinWord": "KEEP_WORD",
                "breakNonLatinWord": "KEEP_WORD",
                "widowOrphan": "0",
                "keepWithNext": "0",
                "keepLines": "0",
                "pageBreakBefore": "0",
                "lineWrap": "BREAK",
            },
        )
        ET.SubElement(para, _q("hh", "autoSpacing"), {"eAsianEng": "0", "eAsianNum": "0"})
        margin_el = ET.SubElement(para, _q("hh", "margin"))
        margin_values = {"intent": "0", "left": "0", "right": "0", "prev": "0", "next": "0"}
        if margin:
            for key, value in margin.items():
                if key in margin_values:
                    margin_values[key] = str(value)
        for key, value in margin_values.items():
            ET.SubElement(margin_el, _q("hc", key), {"value": value, "unit": "HWPUNIT"})
        ET.SubElement(
            para,
            _q("hh", "lineSpacing"),
            {"type": "PERCENT", "value": str(line_spacing_value), "unit": "PERCENT"},
        )
        ET.SubElement(
            para,
            _q("hh", "border"),
            {
                "borderFillIDRef": border_fill_id,
                "offsetLeft": "0",
                "offsetRight": "0",
                "offsetTop": "0",
                "offsetBottom": "0",
                "connect": "0",
                "ignoreMargin": "0",
            },
        )

    para_defs = [
        (0, "JUSTIFY", 160, {"font_line_height": "1", "snap_to_grid": "0"}),
        (1, "CENTER", 130, {}),
        (2, "LEFT", 160, {}),
        (3, "LEFT", 160, {}),
        (4, "LEFT", 160, {}),
        (5, "LEFT", 160, {}),
        (6, "CENTER", 130, {}),
        # 예비 paraPr 5종 (Option A 대비)
        (7, "LEFT", 150, {"font_line_height": "0", "snap_to_grid": "1"}),
        (
            8,
            "LEFT",
            160,
            {
                "font_line_height": "0",
                "snap_to_grid": "1",
                # DESC2 hanging indent 37.5pt → 3750 HWP units.
                "margin": {"intent": -3750},
            },
        ),
        (
            9,
            "JUSTIFY",
            160,
            {
                "font_line_height": "0",
                "snap_to_grid": "0",
                # Body paragraphs target 30pt indent (3000 HWP units).
                "margin": {"intent": -3000},
            },
        ),
        (
            10,
            "LEFT",
            160,
            {
                "font_line_height": "0",
                "snap_to_grid": "1",
                # DESC3 indent tuned to 35pt (3500 HWP units) while staying left aligned.
                "margin": {"intent": -3500},
            },
        ),
        (11, "LEFT", 135, {"font_line_height": "0", "snap_to_grid": "1"}),
        (12, "RIGHT", 160, {"font_line_height": "0", "snap_to_grid": "1"}),  # 머리말
        (13, "RIGHT", 160, {"font_line_height": "0", "snap_to_grid": "1"}),  # 꼬리말
        (14, "CENTER", 160, {"font_line_height": "0", "snap_to_grid": "1"}),  # 표 제목
        (15, "CENTER", 130, {"font_line_height": "0", "snap_to_grid": "1"}),  # 표 헤더
        (16, "CENTER", 130, {"font_line_height": "0", "snap_to_grid": "1"}),  # 표 본문
        (17, "CENTER", 130, {"font_line_height": "0", "snap_to_grid": "1"}),  # 요약표 셀 wrapper
        (
            18,
            "LEFT",
            130,
            {
                "font_line_height": "0",
                "snap_to_grid": "1",
                "margin": {"intent": 0},
            },
        ),  # 요약표 본문 (들여쓰기 0)
        (
            19,
            "LEFT",
            130,
            {
                "font_line_height": "0",
                "snap_to_grid": "1",
                "margin": {"intent": 500},
            },
        ),  # 요약표 설명 (들여쓰기 5pt)
        (12, "RIGHT", 130, {"font_line_height": "0", "snap_to_grid": "1"}),  # 머리말
        (13, "RIGHT", 130, {"font_line_height": "0", "snap_to_grid": "1"}),  # 꼬리말
    ]
    for pid, align, spacing, extra in para_defs:
        add_para_pr(
            pid,
            align,
            spacing,
            font_line_height=extra.get("font_line_height", "0"),
            snap_to_grid=extra.get("snap_to_grid", "1"),
            margin=extra.get("margin"),
            border_fill_id=extra.get("border_fill_id", "1"),
        )
    para_props.set("itemCnt", str(len(para_defs)))

    # numberings: 번호 매기기 정의 (참조 파일 기준)
    numberings = ET.SubElement(ref_list, _q("hh", "numberings"), {"itemCnt": "1"})
    numbering = ET.SubElement(numberings, _q("hh", "numbering"), {"id": "1", "start": "0"})

    # 10개 레벨의 paraHead 추가
    levels = [
        {"level": "1", "numFormat": "DIGIT", "text": "^1."},
        {"level": "2", "numFormat": "HANGUL_SYLLABLE", "text": "^2."},
        {"level": "3", "numFormat": "DIGIT", "text": "^3)"},
        {"level": "4", "numFormat": "HANGUL_SYLLABLE", "text": "^4)"},
        {"level": "5", "numFormat": "DIGIT", "text": "(^5)"},
        {"level": "6", "numFormat": "HANGUL_SYLLABLE", "text": "(^6)"},
        {"level": "7", "numFormat": "CIRCLED_DIGIT", "checkable": "1", "text": "^7"},
        {"level": "8", "numFormat": "CIRCLED_HANGUL_SYLLABLE", "checkable": "1", "text": "^8"},
        {"level": "9", "numFormat": "HANGUL_JAMO", "text": ""},
        {"level": "10", "numFormat": "ROMAN_SMALL", "checkable": "1", "text": ""},
    ]

    for lvl in levels:
        attrs = {
            "start": "1",
            "level": lvl["level"],
            "align": "LEFT",
            "useInstWidth": "1",
            "autoIndent": "1",
            "widthAdjust": "0",
            "textOffsetType": "PERCENT",
            "textOffset": "50",
            "numFormat": lvl["numFormat"],
            "charPrIDRef": "4294967295",
            "checkable": lvl.get("checkable", "0"),
        }
        para_head = ET.SubElement(numbering, _q("hh", "paraHead"), attrs)
        para_head.text = lvl["text"]

    # styles: BlockType별 문단 스타일 정의
    styles = ET.SubElement(ref_list, _q("hh", "styles"), {"itemCnt": "0"})

    def add_style(style_id: int, name: str, eng_name: str, para_ref: int, char_ref: int) -> None:
        ET.SubElement(
            styles,
            _q("hh", "style"),
            {
                "id": str(style_id),
                "type": "PARA",
                "name": name,
                "engName": eng_name,
                "paraPrIDRef": str(para_ref),
                "charPrIDRef": str(char_ref),
                "nextStyleIDRef": str(style_id),
                "langID": "1042",
                "lockForm": "0",
            },
        )

    style_defs = [
        (0, "바탕글", "Normal", 0, 0),
        (1, "주제목", "MainTitle", 1, 5),
        (2, "소제목", "SubTitle", 2, 6),
        (3, "본문", "Body", 9, 0),
        (4, "설명2", "Desc2", 8, 0),
        (5, "설명3", "Desc3", 10, 7),
        (6, "강조", "Emphasis", 6, 8),
        (7, "예비제목", "ReserveHeading", 7, 5),
        (8, "예비본문A", "ReserveBodyA", 8, 0),
        (9, "예비본문B", "ReserveBodyB", 9, 7),
        (10, "예비캡션", "ReserveCaption", 10, 7),
        (11, "예비강조", "ReserveEmphasis", 11, 8),
        (12, "머리말", "Header", int(HEADER_PARA_ID), int(HEADER_CHAR_ID)),
        (13, "꼬리말", "Footer", int(FOOTER_PARA_ID), int(FOOTER_CHAR_ID)),
        (14, "표제목", "TableTitle", int(TABLE_TITLE_PARA_ID), 7),
        (15, "표헤더", "TableHeader", int(TABLE_HEADER_PARA_ID), int(TABLE_HEADER_CHAR_ID)),
        (16, "표본문", "TableBody", int(TABLE_BODY_PARA_ID), int(TABLE_BODY_CHAR_ID)),
        (17, "요약본문", "SummaryBody", int(SUMMARY_BODY_PARA_ID), 7),
        (18, "요약설명", "SummaryDesc", int(SUMMARY_DESC_PARA_ID), int(TABLE_BODY_CHAR_ID)),
    ]
    for sid, name, eng, para_ref, char_ref in style_defs:
        add_style(sid, name, eng, para_ref, char_ref)
    styles.set("itemCnt", str(len(style_defs)))

    # compatibility / options (한글 구현 관행에 맞춤)
    compatible = ET.SubElement(head, _q("hh", "compatibleDocument"), {"targetProgram": "HWP201X"})
    ET.SubElement(compatible, _q("hh", "layoutCompatibility"))

    doc_option = ET.SubElement(head, _q("hh", "docOption"))
    ET.SubElement(
        doc_option,
        _q("hh", "linkinfo"),
        {"path": "", "pageInherit": "0", "footnoteInherit": "0"},
    )

    ET.SubElement(head, _q("hh", "trackchageConfig"), {"flags": "56"})

    return ET.tostring(head, encoding="utf-8", xml_declaration=True)


def build_section0_xml(blocks: List[Block], doc_meta: DocumentMetadata) -> bytes:
    """Build section0.xml with hs:sec root and content paragraphs.

    - 첫 부분에 머리말/꼬리말 컨트롤을 추가한다.
    - 본문 첫 실질 문단에는 페이지/섹션 설정을 위한 hp:secPr를 포함한다.
    """

    root = ET.Element(
        _q("hs", "sec"),
        {
            "xmlns:ha": NS["ha"],
            "xmlns:hp": NS["hp"],
            "xmlns:hp10": NS["hp10"],
            "xmlns:hs": NS["hs"],
            "xmlns:hc": NS["hc"],
            "xmlns:hh": NS["hh"],
            "xmlns:hhs": NS["hhs"],
            "xmlns:hm": NS["hm"],
            "xmlns:hpf": NS["hpf"],
            "xmlns:dc": NS["dc"],
            "xmlns:opf": NS["opf"],
            "xmlns:ooxmlchart": NS["ooxmlchart"],
            "xmlns:hwpunitchar": NS["hwpunitchar"],
            "xmlns:epub": NS["epub"],
            "xmlns:config": NS["config"],
        },
    )

    # 텍스트가 하나도 없으면 빈 문단 하나라도 만들어 둔다.
    text_blocks = [b for b in blocks if b.text]
    if not text_blocks:
        text_blocks = [Block(BlockType.PLAIN, "", "테스트입니다")]  # fallback

    # 본문 문단/테이블을 먼저 구성한 뒤, 마지막에 머리말/꼬리말 ctrl을 주입한다.
    p_id = 0
    secpr_attached = False
    table_id = 0

    # Option A flag (2025-11-16): paragraph layout/indent tweaks are deferred until
    # Tier1 parity testing proves stable. Do not modify the geometry logic below
    # without running the full validator loop on converter/sample_input.md.
    for block in text_blocks:
        if isinstance(block, TableBlock):
            p_id, table_id, secpr_attached = _append_markdown_table(
                root, block, table_id=table_id, p_id=p_id, secpr_attached=secpr_attached
            )
            continue
        if isinstance(block, SummaryTableBlock):
            p_id, table_id, secpr_attached = _append_summary_table(
                root, block, table_id=table_id, p_id=p_id, secpr_attached=secpr_attached
            )
            continue

        # 1) 필요하면 spacer 문단 추가
        spacer_char_id = SPACER_CHAR_MAP.get(block.type)
        if spacer_char_id is not None:
            spacer_marker = SPACER_MARKER_MAP.get(block.type, "↕↕")
            p = ET.SubElement(
                root,
                _q("hp", "p"),
                {
                    "id": str(p_id),
                    "paraPrIDRef": "0",
                    "styleIDRef": "0",
                    "pageBreak": "0",
                    "columnBreak": "0",
                    "merged": "0",
                },
            )
            # spacer에는 secPr를 붙이지 않는다
            run_sp = ET.SubElement(p, _q("hp", "run"), {"charPrIDRef": spacer_char_id})
            t_sp = ET.SubElement(run_sp, _q("hp", "t"))
            t_sp.text = spacer_marker
            p_id += 1

        if block.type == BlockType.TITLE:
            p_id, table_id, secpr_attached = _append_title_table(
                root, block, table_id=table_id, p_id=p_id, secpr_attached=secpr_attached
            )
            continue
        if block.type == BlockType.EMPHASIS:
            p_id, table_id, secpr_attached = _append_emphasis_table(
                root, block, table_id=table_id, p_id=p_id, secpr_attached=secpr_attached
            )
            continue

        # 2) 실제 내용 문단
        para_id = PARA_STYLE_MAP.get(block.type, "0")
        style_id = STYLE_ID_MAP.get(block.type, "0")
        p = ET.SubElement(
            root,
            _q("hp", "p"),
            {
                "id": str(p_id),
                "paraPrIDRef": para_id,
                "styleIDRef": style_id,
                "pageBreak": "0",
                "columnBreak": "0",
                "merged": "0",
            },
        )

        # 첫 실제 문단에만 secPr/페이지 설정 포함
        if not secpr_attached:
            char_id_for_sec = RUN_CHAR_OVERRIDE_MAP.get(block.type)
            run_sec_attrs = {}
            if char_id_for_sec is not None:
                run_sec_attrs["charPrIDRef"] = char_id_for_sec
            run_sec = ET.SubElement(p, _q("hp", "run"), run_sec_attrs)
            _attach_secpr(run_sec)
            secpr_attached = True

        # 실제 텍스트 run (inline bold 지원)
        char_id = RUN_CHAR_OVERRIDE_MAP.get(block.type)
        if block.type == BlockType.SUBTITLE:
            text_content = f"□ {block.text}"
        elif block.type == BlockType.BODY:
            text_content = f" ◦ {block.text}"
        elif block.type == BlockType.DESC2:
            text_content = f"   - {block.text}"
        elif block.type == BlockType.DESC3:
            text_content = f"    * {block.text}"
        elif block.type == BlockType.EMPHASIS:
            text_content = f"◈ {block.text}"
        else:
            text_content = block.text

        _append_text_with_bold(p, char_id, text_content)

        p_id += 1

    # 머리말/꼬리말 텍스트를 만들고, 섹션 구조가 예상과 다르면 조용히 무시한다.
    try:
        header_text, footer_text = _build_header_footer_text(doc_meta)
        _append_header_footer_ctrl(root, header_text, footer_text)
    except Exception:
        pass

    return ET.tostring(root, encoding="utf-8", xml_declaration=True)


def build_content_hpf(doc_meta: DocumentMetadata) -> bytes:
    """Build Contents/content.hpf (opf:package) with manifest and spine."""

    root = ET.Element(
        _q("opf", "package"),
        {
            "version": "",
            "unique-identifier": "",
            "id": "",
            "xmlns:ha": NS["ha"],
            "xmlns:hp": NS["hp"],
            "xmlns:hp10": NS["hp10"],
            "xmlns:hs": NS["hs"],
            "xmlns:hc": NS["hc"],
            "xmlns:hh": NS["hh"],
            "xmlns:hhs": NS["hhs"],
            "xmlns:hm": NS["hm"],
            "xmlns:hpf": NS["hpf"],
            "xmlns:hwpunitchar": NS["hwpunitchar"],
            "xmlns:ooxmlchart": NS["ooxmlchart"],
            "xmlns:dc": NS["dc"],
            "xmlns:epub": NS["epub"],
            "xmlns:config": NS["config"],
            "xmlns:ocf": NS["ocf"],
            "xmlns:rdf": NS["rdf"],
            "xmlns:pkg": NS["pkg"],
        },
    )

    # Metadata
    metadata_el = ET.SubElement(root, _q("opf", "metadata"))
    title_el = ET.SubElement(metadata_el, _q("opf", "title"))
    title_el.text = doc_meta.title or "Untitled"
    lang_el = ET.SubElement(metadata_el, _q("opf", "language"))
    lang_el.text = "ko"
    meta_entries = [
        ("creator", doc_meta.creator),
        ("subject", doc_meta.subject),
        ("description", doc_meta.description),
        ("lastsaveby", doc_meta.last_saved_by),
        ("CreatedDate", _isoformat_utc(doc_meta.created_at)),
        ("ModifiedDate", _isoformat_utc(doc_meta.modified_at)),
        ("date", doc_meta.display_date),
        ("keyword", doc_meta.keyword),
    ]
    for name, value in meta_entries:
        ET.SubElement(
            metadata_el,
            _q("opf", "meta"),
            {
                "name": name,
                "content": value or "",
            },
        )

    # Manifest - list all content files
    manifest = ET.SubElement(root, _q("opf", "manifest"))
    ET.SubElement(
        manifest,
        _q("opf", "item"),
        {"id": "header", "href": "Contents/header.xml", "media-type": "application/xml"},
    )
    ET.SubElement(
        manifest,
        _q("opf", "item"),
        {"id": "section0", "href": "Contents/section0.xml", "media-type": "application/xml"},
    )
    ET.SubElement(
        manifest,
        _q("opf", "item"),
        {"id": "settings", "href": "settings.xml", "media-type": "application/xml"},
    )

    # Spine - define reading order (required by Hangul)
    spine = ET.SubElement(root, _q("opf", "spine"))
    ET.SubElement(spine, _q("opf", "itemref"), {"idref": "header", "linear": "yes"})
    ET.SubElement(spine, _q("opf", "itemref"), {"idref": "section0", "linear": "no"})

    return ET.tostring(root, encoding="utf-8", xml_declaration=True)


def build_container_xml() -> bytes:
    """Build META-INF/container.xml pointing to Contents/content.hpf and container.rdf.

    Based on test_inputmodel.hwpx structure.
    """

    root = ET.Element(_q("ocf", "container"))
    root.set("xmlns:hpf", NS["hpf"])
    rootfiles = ET.SubElement(root, _q("ocf", "rootfiles"))

    # Main content file
    ET.SubElement(
        rootfiles,
        _q("ocf", "rootfile"),
        {
            "full-path": "Contents/content.hpf",
            "media-type": "application/hwpml-package+xml",
        },
    )

    # Preview text for Hangul quick preview
    ET.SubElement(
        rootfiles,
        _q("ocf", "rootfile"),
        {
            "full-path": "Preview/PrvText.txt",
            "media-type": "text/plain",
        },
    )

    # RDF metadata (required by Hangul)
    ET.SubElement(
        rootfiles,
        _q("ocf", "rootfile"),
        {
            "full-path": "META-INF/container.rdf",
            "media-type": "application/rdf+xml",
        },
    )

    return ET.tostring(root, encoding="utf-8", xml_declaration=True)


def build_version_xml() -> bytes:
    """Build version.xml (HCFVersion) with all required attributes.

    Based on test_inputmodel.hwpx structure.
    """

    hv_ns = "http://www.hancom.co.kr/hwpml/2011/version"
    root = ET.Element(
        f"{{{hv_ns}}}HCFVersion",
        {
            "tagetApplication": "WORDPROCESSOR",
            "major": "5",
            "minor": "1",
            "micro": "0",
            "buildNumber": "1",
            "os": "1",
            "xmlVersion": "1.4",
            "application": "Hancom Office Hangul",
            "appVersion": "11, 0, 0, 8808 WIN32LEWindows_10",
        },
    )
    root.set("xmlns:hv", hv_ns)
    return ET.tostring(root, encoding="utf-8", xml_declaration=True)


def build_settings_xml() -> bytes:
    """Build settings.xml with CaretPosition.

    Based on test_inputmodel.hwpx structure.
    """

    root = ET.Element(_q("ha", "HWPApplicationSetting"))
    root.set("xmlns:config", "urn:oasis:names:tc:opendocument:xmlns:config:1.0")

    # Add caret position (required by Hangul)
    ET.SubElement(
        root,
        _q("ha", "CaretPosition"),
        {"listIDRef": "0", "paraIDRef": "0", "pos": "0"},
    )

    return ET.tostring(root, encoding="utf-8", xml_declaration=True)


def build_manifest_xml() -> bytes:
    """Build META-INF/manifest.xml (ODF manifest structure).

    Based on test_inputmodel.hwpx structure.
    Required by Hangul for package validation.
    """

    odf_ns = "urn:oasis:names:tc:opendocument:xmlns:manifest:1.0"
    root = ET.Element(f"{{{odf_ns}}}manifest")
    root.set("xmlns:odf", odf_ns)

    return ET.tostring(root, encoding="utf-8", xml_declaration=True)


def build_container_rdf() -> bytes:
    """Build META-INF/container.rdf (RDF metadata linking document parts).

    Based on test_inputmodel.hwpx structure.
    Required by Hangul for proper document structure recognition.
    """

    root = ET.Element(_q("rdf", "RDF"))

    about_attr = {f"{{{NS['rdf']}}}about": ""}
    resource_header = {f"{{{NS['rdf']}}}resource": "Contents/header.xml"}
    resource_section = {f"{{{NS['rdf']}}}resource": "Contents/section0.xml"}

    desc_root = ET.SubElement(root, _q("rdf", "Description"), about_attr.copy())
    ET.SubElement(desc_root, _q("pkg", "hasPart"), resource_header.copy())

    desc_header = ET.SubElement(root, _q("rdf", "Description"), {f"{{{NS['rdf']}}}about": "Contents/header.xml"})
    ET.SubElement(desc_header, _q("rdf", "type"), {
        f"{{{NS['rdf']}}}resource": f"{NS['pkg']}HeaderFile"
    })

    desc_root_section = ET.SubElement(root, _q("rdf", "Description"), about_attr.copy())
    ET.SubElement(desc_root_section, _q("pkg", "hasPart"), resource_section.copy())

    desc_section = ET.SubElement(root, _q("rdf", "Description"), {f"{{{NS['rdf']}}}about": "Contents/section0.xml"})
    ET.SubElement(desc_section, _q("rdf", "type"), {
        f"{{{NS['rdf']}}}resource": f"{NS['pkg']}SectionFile"
    })

    desc_type = ET.SubElement(root, _q("rdf", "Description"), about_attr.copy())
    ET.SubElement(desc_type, _q("rdf", "type"), {
        f"{{{NS['rdf']}}}resource": f"{NS['pkg']}Document"
    })

    return ET.tostring(root, encoding="utf-8", xml_declaration=True)


# ---------------------------------------------------------------------------
# Writing .hwpx container (realistic minimal package)
# ---------------------------------------------------------------------------


def write_hwpx(blocks: List[Block], output_path: Path) -> None:
    """Write a complete HWPX (ZIP) container with all required files.

    Files included (based on test_inputmodel.hwpx structure):
    - mimetype
    - version.xml
    - settings.xml
    - META-INF/manifest.xml (NEW - required)
    - META-INF/container.xml
    - META-INF/container.rdf (NEW - required)
    - Contents/header.xml
    - Contents/section0.xml
    - Contents/content.hpf
    """

    output_path = output_path.with_suffix(".hwpx")
    output_path.parent.mkdir(parents=True, exist_ok=True)

    metadata = _build_document_metadata(blocks)

    # Build all XML files
    header_bytes = build_header_xml()
    section0_bytes = build_section0_xml(blocks, metadata)
    content_hpf_bytes = build_content_hpf(doc_meta=metadata)
    container_bytes = build_container_xml()
    container_rdf_bytes = build_container_rdf()
    manifest_bytes = build_manifest_xml()
    version_bytes = build_version_xml()
    settings_bytes = build_settings_xml()
    preview_text_bytes = _build_preview_text(blocks, metadata.title).encode("utf-8")

    with zipfile.ZipFile(output_path, "w", compression=zipfile.ZIP_DEFLATED) as zf:
        # mimetype must be first and uncompressed (per OCF spec)
        zf.writestr("mimetype", "application/hwp+zip", compress_type=zipfile.ZIP_STORED)

        # Version and settings
        zf.writestr("version.xml", version_bytes)
        zf.writestr("settings.xml", settings_bytes)

        # Preview assets
        zf.writestr("Preview/PrvText.txt", preview_text_bytes)
        zf.writestr("Preview/PrvImage.png", PREVIEW_PNG_BYTES)

        # META-INF files (all required)
        zf.writestr("META-INF/manifest.xml", manifest_bytes)
        zf.writestr("META-INF/container.xml", container_bytes)
        zf.writestr("META-INF/container.rdf", container_rdf_bytes)

        # Contents files
        zf.writestr("Contents/header.xml", header_bytes)
        zf.writestr("Contents/section0.xml", section0_bytes)
        zf.writestr("Contents/content.hpf", content_hpf_bytes)


# ---------------------------------------------------------------------------
# High-level conversion API & CLI entrypoint
# ---------------------------------------------------------------------------


def convert_md_to_hwpx(input_md_path: Path, output_hwpx_path: Path) -> None:
    lines = input_md_path.read_text(encoding="utf-8").splitlines(True)
    blocks = parse_md_lines(lines)
    write_hwpx(blocks, output_hwpx_path)


def main() -> int:
    parser = argparse.ArgumentParser(description="Phase1 MD → HWPX converter (skeleton)")
    parser.add_argument("input_md", type=Path, help="Input markdown file (e.g., converter/sample_input.md)")
    parser.add_argument("output_hwpx", type=Path, help="Output HWPX file path (without .hwpx suffix also ok)")
    args = parser.parse_args()

    convert_md_to_hwpx(args.input_md, args.output_hwpx)
    print(f"[ok] Converted {args.input_md} → {args.output_hwpx.with_suffix('.hwpx')}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
